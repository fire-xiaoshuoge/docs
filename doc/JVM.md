# JVM

## 内存布局

### JVM

JVM是Java Virtual Machine（Java[虚拟机](https://baike.baidu.com/item/虚拟机)）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言[编译程序](https://baike.baidu.com/item/编译程序/8290180)只需生成在Java虚拟机上运行的目标代码（[字节码](https://baike.baidu.com/item/字节码/9953683)），就可以在多种平台上不加修改地运行。

### 运行时数据区域

![img](https://gitee.com/mo-se-de-feng/notes/raw/master/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/images/1.1.1%20JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.PNG)

### 程序计数器

序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

### Java虚拟机栈

程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame)]用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

![img](https://images0.cnblogs.com/i/288799/201405/291429030562182.jpg)

1）、局部变量表
就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。

2）、操作数栈
想必学过数据结构中的栈的朋友想必对表达式求值问题不会陌生，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。

3）、指向运行时常量池的引用
因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。

4）、方法返回地址
当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。　由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。

### 本地方法栈

本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如SunHotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

### Java堆

对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

![heap](https://img-blog.csdn.net/2018031000051841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

（1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。
（4） 所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。

堆空间内存分配（默认情况下）

老年代 ： 三分之二的堆空间
年轻代 ： 三分之一的堆空间 

eden区： 8/10 的年轻代空间
survivor0 : 1/10 的年轻代空间
survivor1 : 1/10 的年轻代空间

#### 年轻代（Young Generation）

对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉，这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在年轻代上的GC。
年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为：

![这里写图片描述](https://img-blog.csdn.net/20160730191837045)

绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。
从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方 式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是复制算法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）。

#### 年老代（Old Generation）

对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　
可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。
如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。
可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。

#### 永久代（Permanent Generation方法区）

永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：

- 类的所有实例都已经被回收
- 加载类的ClassLoader已经被回收
- 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）

### 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

### java8内存模型图

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180312125453153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJ1Y2UxMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 类加载

### 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）。

![img](https://gitee.com/mo-se-de-feng/notes/raw/master/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/images/3.1.1%20%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.PNG)

### 初始化

虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

### **类加载方式**

  这里的类加载不是指类加载阶段，而是指整个类加载过程，即类加载阶段到初始化完成。

   （1）隐式加载

创建类对象
使用类的静态域
创建子类对象
使用子类的静态域
在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class
在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class
在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件  

（2）显式加载

ClassLoader.loadClass(className)，只加载和连接、不会进行初始化
Class.forName(String name, boolean initialize,ClassLoader loader); 使用loader进行加载和连接，根据参数initialize决定是否初始化。

### 类加载器

启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。

扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![img](https://gitee.com/mo-se-de-feng/notes/raw/master/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B%E4%B8%93%E9%A2%98/images/3.1.1%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.PNG)

### 双亲委派模型

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

## GC

### java中的引用

#### 强引用(Strong Reference):

强引用就是指在程序代码之中普遍存在的，类似“Object obj = newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

#### 软引用(Sofe Reference):

软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。

#### 弱引用(Weak Reference):

弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。

#### 虚引用(Phantom Reference):

虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。

### 判断对象是否已经死亡

#### 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

#### 可达性分析算法

这个算法的基本思路就是通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

### GC算法

#### 标记-清除算法

最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![img](http://img-blog.csdnimg.cn/20191106195020243.gif)

#### 复制算法

为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。

![image-20200318163942899](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200318163942899.png)

#### 标记-整理算法

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![image-20200318164135595](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200318164135595.png)

#### 分代收集算法

​    GC（Generational Collection）分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。
   “分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

### **垃圾收集器**

#### 串行回收

使用单线程进行垃圾回收，在回收时应用程序（mutator）都需要执行暂停（Stop The World,STW）。新生代通常采用复制算法，老生代通常采用标记压缩算法。

![image-20200323203147483](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323203147483.png)

#### 并行回收

使用多线程进行垃圾回收，在回收时应用程序需要暂停，新生代通常采用复制算法，老生代通常采用标记压缩算法。

![image-20200323203849939](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323203849939.png)



#### **Serial收集器**

串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用**一个线程**去回收。新生代、老年代使用**串行**回收；**新生代复制算法**、**老年代标记-压缩**；垃圾收集的过程中会Stop The World（服务暂停）。

![wpsA77.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174240391-864339858.png)

#### **ParNew收集器**

ParNew收集器其实就是Serial收集器的多线程版本。**新生代并行，老年代串行；**新生代复制算法、老年代标记-压缩。

![wps6A83.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174244797-1533472044.png)

#### **Parallel收集器**

Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的**吞吐量**。可以通过参数来打开**自适应调节策略，**虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩。

#### **Parallel **Old **收集器**

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供。

#### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 

初始标记（CMS initial mark）

并发标记（CMS concurrent mark）

重新标记（CMS remark）

并发清除（CMS concurrent sweep）

 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 
   由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。**老年代收集器**（新生代使用ParNew）。

优点:**并发收集**、**低停顿** 

缺点：产生大量空间碎片、并发阶段会降低吞吐量

![wpsCA6E.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174246485-1027326741.png)

#### **G1**收集器

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：

\1. **空间整合**，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。

\2. **可预测停顿**，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。

![wps3B4C.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174247641-1572774731.jpg)

G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。

G1新生代的回收方式是并行回收，采用复制算法。与其他JVM垃圾回收器一样，一旦发生一次新生代回收，整个新生代都会被回收。这就是我们常说的新生代回收（Young GC, YGC）。但是G1和其他垃圾回收器的不同之处在于：①G1会根据预测时间动态地改变新生代的大小[插图]；②G1老生代的垃圾回收方式与其他JVM垃圾回收器对老生代处理有着极大的不同。G1老生代的回收不会为了释放老生代的空间而对整个老生代进行回收。相反，在任意时刻只有一部分老生代分区会被回收，并且这部分老生代分区将在下一次增量回收时与所有的新生代分区一起被回收，这就是我们所说的混合回收（Mixed GC）。在选择老生代分区时，优先考虑垃圾多的分区。

老生代分区的选择涉及G1的并发标记算法，这个过程称为“并发标记阶段”。并发标记是指并发标记线程和应用程序线程同时运行，它有4个典型的子阶段：初始标记子阶段、并发标记子阶段、再标记子阶段和清理子阶段。

1．初始标记子阶段负责标记所有从根集合直接可达的对象，根集合是对象图的起点，初始标记需要将应用程序线程暂停，也就是需要一个STW的时间段。在混合回收中的初始标记子阶段和新生代的初始标记几乎一样。实际上混合回收的初始标记子阶段是借用了新生代回收的结果，即新生代垃圾回收后的新生代Survivor分区作为根，所以混合回收一定发生在新生代回收之后，且不需要再进行一次初始标记。这就是所谓的“借道”。

2．并发标记子阶段当YGC执行结束之后，如果发现满足并发标记的条件，并发线程就开始进行并发标记。根据新生代的Survivor分区开始并发标记。并发标记的时机是在YGC后，只有内存消耗达到一定的阈值后才会触发。在G1中，这个阈值通过参数InitiatingHeapOccupancyPercent控制（默认值是45，表示的是当已经分配的内存加上本次将分配的内存超过内存总容量的45%时就可以开始并发标记）。多个并发标记线程启动，每个线程每次只扫描一个分区，从而标记出存活对象。在标记的时候还会计算存活对象的数量，同时会计算存活对象所占用的内存大小，并计入分区空间。

并发标记子阶段会对所有分区的对象进行标记。这个阶段并不需要STW，故标记线程和应用程序线程并发运行。使用Snapshot-At-The-Beginning（SATB）算法进行并发标记。

3．再标记子阶段再标记是最后一个标记阶段。在该阶段中，G1需要一个STW的时间段，找出所有未被访问的存活对象，同时完成存活内存数据计算。引入该阶段是为了能够达到结束标记的目标。要结束标记过程，需要满足3个条件：

❑从根（survivor）出发并发标记子阶段已经标记出所有的存活对象。

❑标记栈是空的。

❑所有的引用变更对象都被处理了。这里的引用变更对象包括新增空间分配的对象和引用变更对象，新增空间所有对象被认为都是活跃的（即使对象已经“死亡”也没有关系，在这种情况下只是增加了一些浮动垃圾），引用变更处理的对象通过一个队列记录，在该子阶段会处理这个队列中所有的对象。

前两个条件是很容易满足的，但是满足最后一个条件是很困难的。如果不引入一个STW的再标记过程，那么应用会不断地更新引用，也就是说，会不断地产生新的引用变更，因而永远无法达成完成标记的条件。这个子阶段是并行执行的。

4．清理子阶段再标记子阶段之后是清理子阶段，该子阶段也需要一个STW的时间段。清理子阶段主要执行以下操作：

❑统计存活对象，统计的结果将会用来排序分区，以用于下一次的垃圾回收时分区的选择。

❑交换标记位图，为下次并发标记做准备。

❑把空闲分区放到空闲分区列表中。这里的空闲分区指的是全都是垃圾对象的分区，如果分区中还有活跃对象，则不会释放，真正释放的动作发生在混合回收中。该阶段比较容易引起误解的地方在于，清理子阶段并不会清理垃圾对象，也不会执行存活对象的复制。也就是说，在极端情况下，该阶段结束之后，空闲分区列表将毫无变化，JVM的内存使用情况也毫无变化。该子阶段也是并行执行的。

并发标记阶段完成之后，在下一次进行垃圾回收的时候就会回收垃圾比较多的老生代分区。这时进行的垃圾回收称为混合回收，混合回收和YGC最大的区别就是混合回收不仅仅回收所有的新生代分区，也回收部分垃圾多的老生代分区，所以JVM在实现混合回收时重用了YGC所有的代码，两者的不同之处就在于是否回收老生代分区。整个G1垃圾回收的过程如图1-6所示。

![image-20200323204309051](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323204309051.png)

在G1工作时，还有两个值得注意的地方：

❑G1的引用集RSet处理，它是并发执行的，目的是记录对象的引用关系，能减少垃圾回收过程中的停顿时间。

❑在G1中，并发标记算法使用了SATB算法，该算法是G1并发标记的核心。

引用集RSet的处理是代际管理垃圾回收器中非常重要的一个内容，虽然ZGC目前是单代管理，暂时不会涉及引用集概念，但是ZGC未来很有可能会支持多代管理。另外，ZGC中并发算法和G1的并发标记算法有相似之处，都是基于SATB实现的，但实现方式不同。

#### ZGC

新一代的垃圾回收器一经发布，虽然尚不成熟，但是仍然阻挡不了众多Java程序员对它的追捧。ZGC是为了解决G1的不足，我们先看一下G1有哪些不足。

G1的目标是在可控的停顿时间内完成垃圾回收，所以进行了分区设计，在回收时采用部分内存回收（在YGC时会回收所有新生代分区，在混合回收时会回收所有的新生代分区和部分老生代分区），支持的内存也可以达到几十个GB或者上百个GB。为了进行部分回收，G1实现了RSet管理对象的引用关系。基于G1设计上的特点，导致存在以下问题：

❑停顿时间过长，通常G1的停顿时间要达到几十到几百毫秒；这个数字其实已经非常小了，但是我们知道垃圾回收发生导致应用程序在这几十或者几百毫秒中不能提供服务，在某些场景中，特别是对用户体验有较高要求的情况下不能满足实际需求。

❑内存利用率不高，通常引用关系的处理需要额外消耗内存，一般占整个内存的1%～20%左右。

❑支持的内存空间有限，不适用于超大内存的系统，特别是在内存容量高于100GB的系统中，会因内存过大而导致停顿时间增长。

ZGC作为新一代的垃圾回收器，在设计之初就定义了三大目标：支持TB级内存，停顿时间控制在10ms之内，对程序吞吐量影响小于15%。

ZGC还有以下特点：

❑不分代的垃圾回收器，即垃圾回收时对全量内存进行标记，但是回收时仅针对部分内存回收，优先回收垃圾比较多的页面。

❑仅支持Linux 64位系统，不支持32位平台。

❑不支持使用压缩指针。

❑内存分区管理，且支持不同的分区粒度，在ZGC中分区称为页面（page），有小页面、中页面、大页面3种。

❑具有颜色指针（color pointer），通过设计不同的标记位区分不同的虚拟空间，而这些不同标记位指示的不同虚拟空间通过mmap映射在同一物理地址；颜色指针能够快速实现并发标记、转移和重定位。

❑设计了读屏障，实现了并发标记和并发转移的处理。

#### Shenandoah

Shenandoah最初的目标是把垃圾回收停顿时间降到毫秒级别，并且对内存的支持扩展到太字节（TB）级别。为了降低停顿时间，回收器需要使用更多的线程来并行处理回收任务。如果要在降低停顿时间的同时支持更大的堆空间，那么CPU需要具备更好的多核处理能力。相比于CMS和G1, Shenandoah不仅进行并行的垃圾标记，在压缩堆空间时也是并发进行的。从这一点上看，Shenandoah和ZGC是非常类似的，都是解决了并发转移的问题，不过它们两者在实现上采用不同的方法。目前从效果来看，Shenandoah和ZGC存在竞争关系，当然竞争不是坏事，一方面可以促进社区的蓬勃发展，另外一方面这两个项目可以相互借鉴，这也是为什么在ZGC加入OpenJDK之后，Shenandoah也被整合到OpenJDK。

#### 收集器组合

| ** 新生代GC策略** | **年老代GC策略**  | **说明**       |                                                              |
| ----------------- | ----------------- | -------------- | ------------------------------------------------------------ |
| 组合1             | Serial            | Serial Old     | Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。 |
| 组合2             | Serial            | CMS+Serial Old | CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。 |
| 组合3             | ParNew            | CMS            | 使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。 |
| 组合4             | ParNew            | Serial Old     | 使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。 |
| 组合5             | Parallel Scavenge | Serial Old     | Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 |
| 组合6             | Parallel Scavenge | Parallel Old   | Parallel Old是Serial Old的并行版本                           |
| 组合7             | G1GC              | G1GC           | -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC    #开启 -XX:MaxGCPauseMillis =50         #暂停时间目标 -XX:GCPauseIntervalMillis =200     #暂停间隔目标 -XX:+G1YoungGenSize=512m      #年轻代大小 -XX:SurvivorRatio=6              #幸存区比例 |

### 调优参数

#### JVM参数

| 参数                            | 描述                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| -XX:+AlwaysPreTouch             | JVM启动时分配内存，堆的每个页面都在初始化期间按需置零，而不是在应用程序执行期间递增 |
| -XX:Errorfile = filename        | 错误日志                                                     |
| -XX:+TraceClassLoading          | 跟踪类加载信息                                               |
| -XX:+PrintClassHistogram        | 按下Ctrl+Break后打印类信息                                   |
| -Xmx -Xms                       | 最大堆 最小堆                                                |
| -xx:permSize                    | 永久代大小                                                   |
| -xx:metaspaceSize               | 元数据空间大小                                               |
| -XX:+HeapDumpOnOutOfMemoryError | 当抛出OOM时进行HeapDump                                      |
| -XX:+HeapDumpPath               | OOM时堆导出的路径                                            |
| -XX:OnOutOfMemoryError          | 当发生OOM时执行用户指定的命令                                |

#### GC参数

| 参数                      | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| -XX:ParallelGCThreads     | 并行GC线程数量                                               |
| -XX:ConcGcThreads         | 并发GC线程数量                                               |
| -XX:MaxGCPauseMillis      | 最大停顿时间，单位毫秒，GC尽力保证回收时间不超过设定值       |
| -XX:GCTimeRatio           | 垃圾收集时间占总时间的比值，取值0-100，默认99，即最大允许1%的时间做GC |
| -XX:SurvivorRatio         | 设置eden区大小和survivor区大小的比例，8表示两个survivor:eden=2:8，即一个survivor占年轻代的1/10 |
| -XX:NewRatio              | 新生代和老年代的比，4表示新生代:老年代=1:4，即年轻代占堆的1/5 |
| -verbose:gc，-XX:+PrintGC | 打印GC的简要信息                                             |
| -XX:+PrintGCDetails       | 打印GC详细信息（JDK9之后不再使用）                           |
| -XX:+PrintGCTimeStamps    | 打印GC发生的时间戳（JDK9之后不再使用）                       |
| -Xloggc:log/gc.log        | 指定GC log的位置，以文件输出                                 |
| -XX:PrintHeapAtGC         | 每次GC后都打印堆信息                                         |

![image-20200220154903936](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200220154903936.png)

#### Parallel参数

| 参数                       | 描述                     |
| -------------------------- | ------------------------ |
| -XX:+UseParallelGC         | 新生代使用并行垃圾收集器 |
| -XX:+UseParallelOldGC      | 老年代使用并行垃圾收集器 |
| -XX:ParallelGCThreads      | 设置用于垃圾回收的线程数 |
| -XX:+UseAdaptiveSizePolicy | 打开自适应GC策略         |

#### CMS参数

| 参数                               | 描述                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| -XX:+UseConcMarkSweepGC            | 新生代使用并行收集器，老年代使用CMS+串行收集器               |
| -XX:+UseParNewGC                   | 新生代使用并行收集器，老年代CMS收集器默认开启                |
| -XX:CMSInitiatingOccupanyFraction  | 设置触发GC的阈值，默认68%，如果内存预留空间不够，就会引起concurrent mode failure |
| -XX:+UseCMSCompactAtFullCollection | Full GC后，进行一次整理，整理过程是独占的，会引起停顿时间变长 |
| -XX:+CMSFullGCsBeforeCompaction    | 设置进行几次Full GC后进行一次碎片整理                        |
| -XX:+CMSClassUnloadingEnabled      | 允许对类元数据进行回收                                       |
| -XX:+UseCMSInitiatingOccupanyOnly  | 表示只在达到阈值的时候才进行CMS回收                          |
| -XX:+CMSIncrementalMode            | 使用增量模式，比较适合单CPU                                  |

#### G1参数

| 参数                                  | 描述                                                    |
| ------------------------------------- | ------------------------------------------------------- |
| -XX:G1HeapRegionSize                  | 设置Region大小，默认heap/2000                           |
| -XX:G1MixedGCLiveThresholdPercent     | 老年代依靠Mixed GC, 触发阈值                            |
| -XX:G1OldSetRegionThresholdPercent    | 定多包含在一次Mixed GC中的Region比例                    |
| -XX:+ClassUnloadingWithConcurrentMark | G1增加默认开启，在并发标记阶段结束后，JVM即进行类型卸载 |
| -XX:G1NewSizePercent                  | 新生代的最小比例                                        |
| -XX:G1MaxNewSizePercent               | 新生代的最大比列                                        |
| -XX:G1MixedGCCountTraget              | Mixed GC数量控制                                        |

#### GC日志参数

| 参数选项                                | 含义                                                         |
| :-------------------------------------- | :----------------------------------------------------------- |
| -Xloggc:filename                        | 把GC信息输出到文件中，和verbose:gc的内容是一样的。如果这两个命令一起使用的话，Xloggc会覆盖verbose命令 |
| -XX:+PrintGC                            | 打印GC信息                                                   |
| -XX:+PrintGCDetails                     | 打印gc详细信息                                               |
| -XX:+PrintGCApplicationConcurrentTime   | 打印自从上次gc停顿到现在过去了多少时间                       |
| -XX:+PrintGCApplicationStoppedTime      | 打印gc一共停顿了多长时间                                     |
| -XX:+PrintGCDateStamps                  | 打印gc时间                                                   |
| -XX:+PrintGCTimeStamps                  | 打印gc时间戳                                                 |
| -XX:+PrintGCTaskTimeStamps              | 为每个独立的gc线程打印时间戳                                 |
| -XX:+PrintStringDeduplicationStatistics | 打印字符串去重统计信息                                       |
| -XX:+PrintTenuringDistribution          | 打印各代信息                                                 |
| -XX:+TraceClassLoading                  | 跟踪类的加载信息,当类加载的时候输入该类，默认关闭            |
| -XX:+TraceClassLoadingPreorder          | 按照引用顺序跟踪类加载。默认关闭                             |
| -XX:+TraceClassResolution               | 跟踪常量池，默认关闭                                         |
| -XX:+TraceClassUnloading                | 跟踪类的卸载信息，默认关闭                                   |
| -XX:+TraceLoaderConstraints             | 跟踪类加载器约束的相关信息，默认关闭                         |
| -XX:-PrintCommandLineFlags              | 输出JVM设置的选项和值，比如：堆大小、垃圾回收器等。默认这个选项是关闭的。 |
| -XX:-CITime                             | 打印消耗在JIT编译的时间                                      |
| -XX:+G1PrintHeapRegions                 | 打印G1收集器收集的区域。默认这个选项是关闭的。               |
| -XX:ErrorFile=./hs_err_pid.log          | 如果JVM crashed，将错误日志输出到指定文件路径。              |
| -XX:-HeapDumpOnOutOfMemoryError         | 在OOM时，输出一个dump.core文件，记录当时的堆内存快照。       |
| -XX:HeapDumpPath=./java_pid.hprof       | 堆内存快照的存储文件路径。                                   |
| -XX:-PrintCompilation                   | 打印方法被JIT编译时的信息。                                  |

### **常用分析工具**

#### JDK内置工具使用

- **jps**(Java Virtual Machine Process Status Tool)
    查看所有的jvm进程，包括进程ID，进程启动的路径等等。
- **jstack**(Java Stack Trace)
    ① 观察jvm中当前所有线程的运行情况和线程当前状态。
    ② 系统崩溃了？如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
    ③ 系统hung住了？jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
- **jstat**(Java Virtual Machine Statistics Monitoring Tool)
    ① jstat利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对进程的classloader，compiler，gc情况；
    ②监视VM内存内的各种堆和非堆的大小及其内存使用量，以及加载类的数量。
- **jmap**(Java Memory Map)
    监视进程运行中的jvm物理内存的占用情况，该进程内存内，所有对象的情况，例如产生了哪些对象，对象数量；
- **jinfo**(Java Configuration Info)
    观察进程运行环境参数，包括Java System属性和JVM命令行参数

#### **可视化工具**

1、Jconsole

2、VisualVM（https://visualvm.github.io/download.html）

### 调优分析

![image-20200229205257650](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200229205257650.png)

## ZGC

### ZGC内存管理

#### ZGC内存管理

ZGC为了能高效、灵活地管理内存，实现了两级内存管理：虚拟内存和物理内存，并且实现了物理内存和虚拟内存的映射关系。这和操作系统中虚拟地址和物理地址设计思路基本一致。ZGC主要的改进点就是重新定义了虚拟内存和物理内存的映射关系。

#### ZGC多视图映射

由于ZGC仅支持Linux 64位系统，所以可以想象ZGC是通过系统调用mmap来完成地址多视图映射的。ZGC实现多视图映射的过程和2.2.1节基本一致，步骤可以总结如下：

❑创建并打开一个文件描述符，这个文件描述符可以是内存文件描述符，也可以是普通文件描述符（最好是内存文件描述符，其性能更高）。创建并打开文件描述的动作是在JVM启动时完成的，简化的流程图如图2-4所示。

![image-20200323205719896](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323205719896.png)

❑在分配内存的时候，新分配的虚拟地址转化成3个映射视图（Marked0、Marked1和Remapped）中的虚拟地址，再使用mmap映射到这个文件描述符上。

#### 页面设计

为了细粒度地控制内存的分配，和G1一样，ZGC将内存划分成小的分区，在ZGC中称为页面（page）。ZGC支持3种页面，分别为小页面、中页面和大页面。其中小页面指的是2MB的页面空间，中页面指32MB的页面空间，大页面指受操作系统控制的大页。

#### ZGC中的物理内存管理

![image-20200323210210642](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323210210642.png)

#### ZGC中的虚拟内存管理

ZGC的虚拟管理器ZVirtualMemoryManager中最主要的成员函数是alloc和free，其中alloc根据应用程序请求的大小来分配空间，这个空间用ZVirtualMemory来保存，在alloc中对于小页面ZGC会从虚拟空间的头部开始分配，对于中页面和大页面ZGC从虚拟空间的尾部开始分配。

#### ZGC对象分配管理

ZGC的实现类是ZCollectedHeap，它重载了一些关键的函数，主要有对象分配相关的函数、垃圾回收相关的函数以及其他相关的辅助函数。真正实现内存分配、回收、对象标记、转移动作是在ZHeap中。

ZCollectedHeap的几个重要成员函数。

![image-20200323210343249](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323210343249.png)

ZCollectedHeap的成员变量。

![image-20200323210359931](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323210359931.png)

![image-20200323210419661](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323210419661.png)

####  页面分配

![image-20200323210539249](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323210539249.png)

### ZGC线程

#### 控制线程

ZGC新引入的3大基础线程分别为ZDirector、ZDriver和ZStat。它们的功能分别为：

❑ZDirector：控制什么时候启动垃圾回收。

❑ZDriver：控制垃圾回收执行的步骤，ZGC垃圾回收一共分为10步，这10步是串行执行的。

❑ZStat：收集JVM在运行过程中回收垃圾时各个阶段的数据，同时控制统计信息的输出。3大基础线程的设计思路类似，它们都继承于基类ConcurrentGCThread，基类提供的功能主要有：

1）创建并启动线程。

2）重载虚函数run()，完成线程资源的初始化，如栈大小的设置、设置线程的名称、设置JNI句柄的分配空间等；调用抽象方法run_service()，各控制线程实现自己的业务逻辑；终止本线程。

#### 工作线程

为了描述方便，我们把并行执行任务的线程称为并行工作线程，把和应用程序并发工作的垃圾回收线程称为并发工作线程。本书中谈论的工作线程指的就是这两类，我们做一个简单的总结：

❑并行工作线程：并行执行。指的是在垃圾回收时，首先执行STW，然后多个GC工作线程并行工作。在ZGC中有3步是并行执行的，分别为初始标记、再标记和转移根对象。

❑并发工作线程：并发执行。指的是在垃圾回收时，除了3步由GC工作线程并行执行外，其余的7步都是可以并发地和应用程序同时执行，这7步分别为并发标记、非强引用处理、重置转移集、回收无效的页面、选择待回收的转移集、准备转移、并发转移，这7步中有3步由并发工作线程处理，有4步是由ZDriver完成的，而非通过并发工作线程完成。

#### 垃圾回收触发的时机

1．基于固定时间间隔触发

2．预热规则触发

3．根据分配速率

1）收集数据：在程序运行时，收集过去一段时间内垃圾回收发生的次数和执行的时间、内存分配的速率memratio和当前空闲内存的大小memfree。

2）计算：根据过去垃圾回收发生的情况预测下一次垃圾回收发生的时间timegc，按照内存分配的速率预测空闲内存能支撑应用程序运行的实际timeoom，例如timeoom=memfree/ memratio。

3）设计规则：如当timeoom小于timegc（垃圾回收的时间），则可以启动垃圾回收。这个规则的含义是如果从现在起到OOM发生前开始执行垃圾回收，刚好在OOM发生前完成垃圾回收的动作，从而避免OOM。在ZGC中ZDirector是周期运行的，所以在计算时还应该把OOM的时间减去采样周期的时间，采样周期记为timeinterval，则规则为timeoom<timegc+ timeinterval时触发垃圾回收。

4）直接采用已经成熟的模型来预测下一次垃圾回收时间。ZGC中主要是基于正态分布来预测。

4．主动触发

5．阻塞内存分配请求触发

6．外部触发

7．元数据分配触发

### ZGC垃圾回收算法

#### ZGC并发算法的设计

ZGC并发垃圾回收算法，整个垃圾回收算法包括10个步骤，我们具体看一下每一步所完成的工作：

1）初始标记，该步骤从根集合出发，找出根集合直接引用的活跃对象，并入栈；该步需要STW。

2）并发标记，根据初始标记找到的对象，作为并发标记的根对象，使用深度优先遍历对象的成员变量进行标记；并发标记需要解决标记过程中引用关系变化导致的漏标记问题。

3）再标记和非强根并行标记，在并发标记结束后尝试终结标记动作，理论上并发标记结束后所有待标记的对象会全部完成，但是因为GC工作线程和应用程序线程是并发运行，所以可能存在GC工作线程执行结束标记时，应用程序线程又有新的引用关系变化导致漏标记，所以这一步先判断是否真的结束了对象的标记，如果没有结束就还会启动并行标记，所以这一步需要STW。另外，在该步中，还会对非强根进行并行标记。

4）并发处理非强引用和非强根并发标记，在非强引用处理时对定义了finalize()函数的对象需要特殊处理，为此ZGC设计了特殊的标记。另外，ZGC为了优化停顿时间，把一些需要在STW中并行处理的任务并发运行，这都被设计成非强根的并发标记。

5）重置转移集合中的页面，实际上第一次垃圾回收时无须处理这一步。

6）回收无效的页面，实际上在内存充足的情况下不会触发这一步。

7）并发选择对象的转移集合，转移集合中就是待回收的页面。

8）并发初始化转移集合中的每个页面，在后续重定位（也称为Remap）时需要的对象转移表（Forward Table）就是在这一步初始化的。

9）转移根对象引用的对象，该步需要STW。

10）并发转移，把对象移动到新的页面中，这样对象所在的老的页面中所有活跃对象都被转移了，页面就可以被回收重用。

ZGC垃圾回收过程的活动图如图4-3所示。

![image-20200323215248950](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323215248950.png)

### ZGC日志解读

#### Xlog

我们可以通过命令java-Xlog:help查看Xlog的使用方法。

![image-20200323215546670](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323215546670.png)

#### 垃圾回收过程中每一步的信息

垃圾回收过程第1步——初始标记花费的时间，为0.222ms。这一阶段需要STW。

![image-20200323215926606](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323215926606.png)

垃圾回收过程第2步——并发标记花费的时间，为31.262ms。整体来看这一阶段花费的时间比较长，但这一阶段和应用程序并发执行，应用程序还可以对外提供服务，然而因为部分计算机资源用于标记，所以会降低应用程序的吞吐量。

![image-20200323215941103](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323215941103.png)

垃圾回收过程第3步——再标记和非强根标记花费的时间，为0.07ms。这一阶段需要STW。

![image-20200323220009161](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220009161.png)

垃圾回收过程第4步——引用处理和非强根并发标记花费的时间，为0.171ms。

![image-20200323220022497](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220022497.png)

垃圾回收过程第5步——重置转移集花费的时间，为0.001ms。

![image-20200323220035588](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220035588.png)

垃圾回收过程第6步——并发回收页面花费的时间，为1.204ms。

![image-20200323220053810](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220053810.png)

垃圾回收过程第7步——并发选择转移集花费的时间，为1.283ms。

![image-20200323220109368](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220109368.png)

垃圾回收过程第8步——并发初始化转移集花费的时间，为0.261ms。

![image-20200323220125665](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220125665.png)

垃圾回收过程第9步——初始转移花费的时间，为0.395ms。这一阶段需要STW。

![image-20200323220138954](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220138954.png)

圾回收过程第10步——并发转移花费的时间，为26.716ms。

![image-20200323220153414](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220153414.png)

整个垃圾回收周期STW花费的时间由第1步、第3步和第9步构成，为0.222 + 0.07 +0.395 =0.687ms。

并发执行的时间由第2、4、5、6、7、8、10步组成，为31.262 + 0.171 + 0.001 + 1.204+1.283 + 0.261 + 26.716 = 60.898ms。

#### 统计信息

Collector显示垃圾回收器在一段时间内垃圾回收执行的情况。

在标记和转移时，会涉及多个线程并发的访问资源，Contention记录的就是标记和转移发生竞争的情况。

Critical（同步等待）信息包含两种信息：在页面分配时使用阻塞分配，或者因为本地线程导致垃圾回收需要等待。

### ZGC参数

#### ZGC新引入参数

ZGC提供的参数比较少，与生产相关的参数只有7个，除了个别参数，大部分不需要修改。

![image-20200323220329602](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220329602.png)

#### GC通用参数

ZGC首先重置和设置了部分通用参数，这一部分参数根据ZGC的特性设置，部分参数不支持修改。对于可以修改的参数，在实际工作中也尽量不要修改，如果要修改参数，需要做充分的测试。

![image-20200323220402272](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220402272.png)

除了上述ZGC重新设置的参数之外，ZGC中还重用了大量的其他参数，比如堆空间设置、编译优化相关参数、逆优化等。这里只列举几个实际工作中常用的参数。

![image-20200323220418344](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220418344.png)

## Shenandoah

#### 概述

Shenandoah的起源要追溯到2014年之前，最早由Red Hat公司发起，目标是利用现代多核CPU的优势，减少大堆内存在垃圾回收时产生的停顿时间。

Shenandoah最初的目标是把垃圾回收停顿时间降到毫秒级，并且将对内存的支持扩展到太字节级别。为了降低停顿时间，回收器需要使用更多的线程来并发处理回收任务，而要在降低停顿时间的同时能够支持更大的堆空间，回收器对CPU的多核处理能力提出了更高的要求。和ZGC类似，Shenandoah不仅进行并发的垃圾标记，在压缩堆空间时也是并发进行的。

![image-20200323220632691](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220632691.png)

#### Shenandoah垃圾回收策略

Shenandoah有一个专门的线程控制是否需要垃圾回收。控制线程每间隔一定时间进行一次判断，决定是否需要进行垃圾回收，如果需要，则启动垃圾回收。

制线程中间隔时间不固定，取值范围在1～10ms之间。时间调整的思路是：当发现内存有变化（通常指应用程序线程或者GC工作线程分配了新的分区）时，间隔1s判断是否需要进行垃圾回收，如果内存没有变化，则间隔时间加倍，最长不超过10ms。

控制线程会决定是否需要进行垃圾回收以及决定进行什么样的垃圾回收。Shenandoah提供6种策略。

![image-20200323220705209](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200323220705209.png)

#### Shenandoah垃圾回收算法

垃圾回收策略决定了Shenandoah何时启动垃圾回收以及在垃圾回收时回收哪些分区。除此之外，Shenandoah为了更好地管理内存，实现了4类垃圾回收算法，分别为：

1）正常回收算法（Normal GC）：垃圾回收的过程通常按照初始标记、并发标记、再标记、并发转移、结束转移的步骤执行。

2）降级回收算法（Degenerated GC）：指在垃圾回收过程中，如果遇到内存分配失败，将进入降级回收。降级回收实质上是在STW中进行的并行回收。

3）全回收算法（Full GC）：如果在降级回收中再次遇到内存分配失败的情况，将进入全回收。

4）遍历回收算法（Traversal GC）：垃圾回收过程按照初始遍历、并发遍历、预清理和结束遍历的步骤执行。