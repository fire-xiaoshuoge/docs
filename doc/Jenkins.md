# Jenkins

## 基础知识

### 脚本式语法

脚本式语法（scripted syntax）是Jenkins最开始实现的流水线即代码方式。这是一种命令式风格，也就是在流水线脚本中定义逻辑和程序流程。它也更依赖于Groovy语言和结构，特别是对于错误检查和异常处理来说。

声明式语法（declarative syntax）是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，相对于只关注实现逻辑，这些流水线的主要区域描述（或“声明”）了我们所期望的流水线的状态和输出。在下面的代码示例中，上面是脚本式语法，下面是对应的声明式语法：

![image-20200519104303912](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519104303912.png)

脚本式流水线更像是一种脚本或编程语言，像其他命令式语言一样可以运行程序和处理逻辑，而声明式流水线则更像Jenkins的传统实现方式，在Web表单的预定义字段中输入关键信息，代表了特定目标和预期行为。与传统的Web表单类似，当执行声明式流水线时，每一个段落定义了基于用户输入数据的执行内容和方式。

简而言之，脚本式流水线具有以下优点。·　更少的代码段落和弱规范要求。·　更强大的程序代码能力。·　更像编写代码程序。·　传统的流水线即代码模型，用户熟悉并向后兼容性。·　更灵活的自定义代码操作。·　能够构建更复杂的工作流和流水线。

脚本式流水线具有以下缺点。·　普遍要求更高的编程水平。·　语法检查受限于Groovy语言及环境。·　和传统Jenkins模型有很大差异。·　与声明式流水线的实现相比，同一工作流会更复杂。

声明式流水线具有以下优点。·　更结构化，贴近传统的Jenkins Web表单形式。·　更强大的声明内容能力，高可读性。·　可以通过Blue Ocean图形化界面自动生成。·　段落可映射到常见的Jenkins概念，比如通知。·　更友好的语法检查和错误识别。·　提升流水线间的一致性。

声明式流水线具有以下缺点。·　对迭代逻辑支持较弱（相比程序而言）。·　仍在开发完善中（对于传统Jenkins中的部分功能缺乏支持）。·　更严格的结构（更难实现自定义流水线代码）。·　目前对于复杂的流水线和工作流难以胜任。

### 主节点

Jenkins主节点是一个Jenkins实例（instance）的主要控制系统。它能够完全访问所有Jenkins配置选项和任务（job）列表。如果没有指定其他系统（system），它也是默认的任务执行节点。

不过并不推荐在主节点上执行高负载任务，任何需要大量处理的任务都应该在主节点之外的系统上运行。

### 节点

在Jenkins 2中，节点是一个基础概念，代表了任何可以执行Jenkins任务的系统。节点中包含主节点和代理节点，有的时候也用于指代这些概念。此外，节点也可以是一个容器，比如Docker。

### 代理节点

在早先版本的Jenkins中，代理节点被称为从节点（slave），其代表了所有非主节点的系统。这类系统由主系统管理，按需分配或指定执行特定的任务。例如，我们可以分配不同的代理节点针对不同的操作系统构建任务，或者可以分配多个代理节点并发地运行测试任务。

### 执行器

简单地说，执行器只是节点/代理节点用于执行任务的一个插槽。一个节点可以有任意多个执行器。执行器的数量定义了该节点可以执行的并发任务数量。当主节点将任务分配给特定节点时，该节点上必须有可用的执行器插槽来立即执行该任务，否则任务会一直处于等待状态，直到一个执行器变为可用。

![image-20200519104915923](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519104915923.png)

###  pipeline

Jenkins pipeline其实就是基于Groovy语言实现的一种DSL（领域特定语言），用于描述整条流水线是如何进行的。流水线的内容包括执行编译、打包、测试、输出测试报告等步骤。

![image-20200421220047039](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200421220047039.png)

• pipeline：代表整条流水线，包含整条流水线的逻辑。

• stage部分：阶段，代表流水线的阶段。每个阶段都必须有名称。本例中，build就是此阶段的名称。

• stages部分：流水线中多个stage的容器。stages部分至少包含一个stage。

• steps部分：代表阶段中的一个或多个具体步骤（step）的容器。steps部分至少包含一个步骤，本例中，echo就是一个步骤。在一个stage中有且只有一个steps。

• agent部分：指定流水线的执行位置（Jenkins agent）。流水线中的每个阶段都必须在某个地方（物理机、虚拟机或Docker容器）执行，agent部分即指定具体在哪里执行。

以上每一个部分（section）都是必需的，少一个，Jenkins都会报错。

### pipeline支持的指令

显然，基本结构满足不了现实多变的需求。所以，Jenkins pipeline通过各种指令（directive）来丰富自己。指令可以被理解为对Jenkins pipeline基本结构的补充。

Jenkins pipeline支持的指令有：

• environment：用于设置环境变量，可定义在stage或pipeline部分。

• tools：可定义在pipeline或stage部分。它会自动下载并安装我们指定的工具，并将其加入PATH变量中。

• input：定义在stage部分，会暂停pipeline，提示你输入内容。

• options：用于配置Jenkins pipeline本身的选项，比如options {retry（3）}指当pipeline失败时再重试2次。options指令可定义在stage或pipeline部分。

• parallel：并行执行多个step。在pipeline插件1.2版本后，parallel开始支持对多个阶段进行并行执行。

• parameters：与input不同，parameters是执行pipeline前传入的一些参数。

• triggers：用于定义执行pipeline的触发器。• when：当满足when定义的条件时，阶段才执行。

## 流水线执行流程

### 触发任务

指定流水线代码的触发事件，有如下3种不同的方法。

·　如果Jenkins应用的本身就是流水线类型的任务，可以使用传统的方法通过Web界面在项目的基本配置部分指定触发条件。

·　如果是创建了一个脚本式流水线，可以在代码中指定一个properties代码块（通常在流水线开始之前）来定义触发条件（注意，这个属性部分将会和Web界面中定义的属性合并处理，并且Web界面上定义的属性优先生效）。

·　如果是创建了一个声明式流水线，有一个特殊的triggers指令可以用来定义流水线的触发类型。

### 在其他项目构建后构建

![image-20200519110056429](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519110056429.png)

### 周期性构建

这种方法提供了一种cron类型的功能，可以按照某个时间间隔启动任务。虽然这是构建的一种方法，但是对于持续集成而言不是最佳选项，持续集成要求基于探测代码管理更新进行构建。但是周期性构建可以用于其他类型的Jenkins应用。

### GitSCM轮询

如果一个GitHub项目被配置为Jenkins项目的代码源，就可以设置一个推钩（在GitHub上）来触发Jenkins项目的构建。在设置好这些后，当有代码推送到代码库时就会发射推钩触发Jenkins，进而调用Jenkins SCM轮询的相应功能。所以必须配置SCM 轮询，才能使GitHub钩子触发器正常工作。

### SCM轮询

这是标准的轮询功能，周期性地扫描源码版本控制系统的变更。如果发现任何更新，任务就会处理这些变化。这种方式可能是相当昂贵的操作（在系统资源方面），取决于SCM类型、扫描哪些内容以及多久扫描一次。

```
trriggers{pollSCM(*/30****)}
```

### 静默期

这里指定的值将作为构建被触发（检测到代码更新）和Jenkins真正执行构建之间的一个“等待时间”或者偏移量。这对于那些经常同一时间有很多变更的任务很有用。如果Jenkins项目中没有配置静默期，将会使用全局配置中的设置。

虽然流水线的build步骤有一个quietPeriod选项，在撰写本书时，还没有一个直接的流水线选项或步骤来设置静默期。你或许可以使用节流并发构建插件（Throttle Concurrent Buildsplugin）提供的throttle（）步骤来实现类似的效果。

### 远程触发构建

对于Jenkins系统上的给定任务，可以访问一个特定URL来触发构建。这对于通过钩子或者脚本来触发构建非常有用。需要一个授权令牌。

### 用户输入

Jenkins任务都具有一个很重要的特性，那就是可以根据用户输入改变它们的行为。Jenkins提供了多种多样的参数类型，可以用来收集用户特定种类的输入。对此，Jenkins流水线也提供了相应的结构。

### input步骤和执行器

本书的前面已定义，一个执行器（executor）是一个节点上用于处理代码的插槽。在node代码块中使用input步骤，就会占用这个节点的执行器直到input步骤完成。

input步骤可以有几个参数，这些参数介绍如下。

消息（message）

显示给用户的消息，正如前面示例所演示的那样。消息也可以为空，表示为input"。

自定义ID（id）

一个ID可以用来标示你的input步骤，便于一些自动化的或者外部的处理，比如，在你希望通过REST API调用来响应的时候。如果没有提供ID，系统也会生成一个唯一的标识符。

URL和Crumb

如果你的Jenkins通过安全设置（强烈推荐）开启了防止跨站请求伪造（CSRF），那么用于POST请求的任何URL也需要包含一个CSRF防卫令牌。

### 参数

布尔型（boolean）

这是基本的true/false参数。布尔类型参数的子参数是名称、默认值及描述。

凭证（credential）

这个参数允许用户选择一个类型并且设置凭证。可用的子参数包括名称、凭证类型、是否必需、默认值及描述。

可选择的凭证类型包括任何、用户名和密码、Docker主机证书验证、SSH用户名及私钥，机密文件、机密文本及证书。

列出Subversion标签（List Subversion tag）

这个参数允许你指定一个Subversion 标签的集合，在构建运行时可以从中选择一个。其子参数包括名称、代码仓库URL、凭证、标签过滤器、默认值、显示标签的最大值，以及按最新标签优先排序和（或）按字母顺序排列选项。

多行字符串（Multiline String）

这个参数允许用户输入多行文本。其子参数包括名称、默认值及描述。

密码（password）

这个参数允许用户输入一个密码。对于密码文本，用户键入的时候会被隐藏起来。可用的子参数包括名称、默认值及描述。

运行（run）

这个参数允许用户从一个任务中选择一个特定的运行（已经执行过的构建）。这个参数可能会被用在如测试环境之中。可用的子参数包括名称、项目、描述及过滤器。

项目子参数就是你允许用户从中选择运行的任务。默认的运行是最新一次的运行。

过滤器子参数允许你基于全部的构建状态，过滤出某类型的运行。选项包括：·　所有构建（包括“运行中”的构建）。·　已完成的构建。·　成功的构建（包括稳定和不稳定的构建）。·　稳定的构建。

字符串（string）

这个参数允许用户输入一个字符串（类似密码参数，但是字符串的值不会被隐藏）。其子参数包括名称、默认值及描述。

### 流程控制选项

超时（timeout）

这个timeout步骤允许你限制等待某个行为发生时脚本所花费的时间。

重试（retry）

这个r e t r y闭包将代码封装为一个步骤，当代码中有异常发生时，该步骤可以重试过程n次。这里n表示你传入retry步骤的一个数值。

睡眠（sleep）

这是一个基本的延时步骤。它接收一个数值并且延迟相应的时间后再继续执行。默认的时间单位是s，所以sleep 5就是等待5s后继续处理。

等待直到（waitUntil）

如果代码块中的过程返回false，那么这个步骤会在等待更长的时间后进行下一次尝试。过程中抛出的任何异常都会导致这个步骤立即退出并且抛出一个错误。

### 处理并发

在大多数情况下，在流水线构建中使用并发是不错的选择。通常这里的并发指的是并行——能够将任务的相似部分同时运行在不同的节点上。这对于运行测试的场景尤其有用，前提是你要适当地限制对资源的重复访问。

### lock步骤对资源加锁

如果你安装了可锁定资源插件（Lockable Resources plugin），系统中就会有一个DSL lock步骤可以用来阻止多个构建在同一时间试图使用同样的资源。（配置系统页面中也会有一个可锁定资源部分，如果必要的话，你可以全局地定义和预约资源——例如，如果你需要临时下线某个系统的一些资源。）

这里的“资源”是泛指。它可能是一个节点、一个代理节点、一组节点或代理节点的集合，或者仅仅是一个用于上锁的名字。如果指定的资源没有在全局配置中定义，那么它将会被自动地添加到系统中。

![image-20200519112118749](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112118749.png)

举一个简单的例子，考虑使用一个声明式流水线，就在我们想使用的某个特定的代理节点上运行构建，而不管有多少个流水线的实例正在运行。（也许这个代理节点是此时唯一安装了某些特殊工具或设备的节点）。使用lock步骤，我们的代码可能看起来如下：

![image-20200519112147402](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112147402.png)

### 使用milestone来控制并发构建

在Jenkins中你可能需要处理的一个场景就是，同一流水线的多个并发在某一时刻构建而发生的资源竞争问题。这些运行可能在不同的时间点以不同的步骤到达某个关键点，或者一个运行可能修改了必要的资源，其他运行达到此点时发现资源的状态不对。总之，我们不能保证在一个运行修改了某个资源之后，其他运行不会出现并且也修改这个资源，而先前的运行还尚未完成。

为了防止出现构建运行顺序（按照启动顺序）混乱而互相踩踏的情况，在Jenkins流水线中可以使用milestone步骤。当一个milestone步骤被放在流水线中时，如果较新的构建已经到达了那里，系统就会阻止较老的构建通过这个里程碑。

![image-20200519112224756](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112224756.png)

### 并行地运行任务

除了一些用于控制流水线逻辑流程的结构，步骤也可以并行地运行。事实上，在流水线DSL中存在专门的结构支持并行地运行步骤——一个传统的结构同时适用于脚本式和声明式流水线，以及一个较新的结构仅适用于声明式流水线。为了突出要点，我们首先谈论一下这个比较通用的结构，然后看看声明式语法中那个较新的结构。

**传统的并行语法**

传统的parallel流水线步骤接收一个映射作为参数。对于这个结构，映射的值通常是由一些pipeline步骤构成的闭包。把这些步骤封装在不同的节点中就可以实现最佳的并行性。如果没有明确指定节点，Jenkins会在空闲的节点上运行这些parallel步骤。

**映射是必需的**

对于这个parallel步骤，如果你没有提供一个映射作为参数，那么你的任务就不会并行地运行。同时，也要注意在该parallel代码块中不能使用阶段（不同于声明式流水线中较新的语法）。

### 并行测试执行器插件

如果在你的流水线中花费相当长的时间测试的话，有一个单独的插件可以帮助你把测试集合并行化。这个并行测试执行器插件（Parallel Test Executor plugin）会查看你所有测试的执行时间，并试图把这些测试分割成基本相同大小的组。（这是通过该插件添加的splitTests DSL步骤完成的）。

这些组被放进对应的列表中，然后你可以把它们映射到流水线的parallel步骤中。在最优情况下，每一组测试都被映射到一个单独的节点上运行。使用这个插件要求你的测试环境：·　创建与JUnit兼容的XML文件。·　使用可以接收文件中的排除测试列表的工具。

### 有条件的执行功能

有史以来，条件性构建步骤插件（Conditional BuildStep plugin）可以让用户在Jenkins自由风格类型的任务中添加一些有条件的执行功能。它允许选择一种方法来测试某些条件，然后基于结果执行一个或者多个构建步骤。

![image-20200519112422608](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112422608.png)

![image-20200519112438712](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112438712.png)

### 构建后处理

传统的（基于Web的）Jenkins自由风格类型任务包含一个构建后操作部分，在那里用户可以添加一些在构建结束后一定发生的行为，不管构建的状态是成功、失败或者被中止。

### 脚本式流水线构建后处理

脚本式流水线没有内置支持构建后处理。在脚本式流水线中，当我们还没有内置功能时，通常依靠Groovy程序结构来提供此功能。这也意味着在这种情况下，我们会使用trycatch-finally机制。

![image-20200519112915432](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112915432.png)

**catchError**

Jenkins流水线语法还提供了一个更加高级的处理异常的方法。

catchError代码块提供了一种方法，可以探测异常以及改变整个构建的状态，还能继续执行流水线进程。使用catchError结构，如果一个代码块抛出了一个异常，那么这个构建会被标记成失败状态。但是，流水线中从catchError代码块往后的语句可以继续执行。

这样处理的优点是，在处理失败后，你依然可以做一些类似发送通知的事情。这不仅模拟了我们所习惯的传统Jenkins模型中的构建后处理过程，而且还提供了一个try-catch代码块的快捷方式。

![image-20200519112958579](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519112958579.png)

### 声明式流水线与构建后处理

声明式流水线中有一个专门的部分可用于构建后处理。不足为奇，这个部分被称为构建后操作（post）。一个post部分可以放在一个阶段的结尾或者一个流水线的结尾——或者同时放在这两个地方。

![image-20200519113035451](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113035451.png)

![image-20200519113048045](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113048045.png)

## 通知与报告

### 通知

在本节中，我们将会看到通知——也就是告知用户一些我们希望他们知道的状态、事件或信息。在大多数情况下，这将发生在流水线的“构建后处理（post-processing）”时期。在脚本式流水线中，如果你想要进行构建后处理（如第3章所述），通常需要使用trycatch-finally结构。 对于声明式流水线，我们可以使用更直接的post部分。

无论你使用何种通知方式，今天用户在 Jenkins 上的选择都远不止传统的电子邮件渠道。更为常见的方式是即时消息传递，甚至可以允许用户为消息指定颜色等操作。我们将在本章中讨论这几种方式。

### 电子邮件

在Jenkins中，电子邮件是通知功能的主要途径。 因此，在Jenkins中配置电子邮件通知是重点支持的功能（也是很重要的选项）。 这些选项在管理Jenkins 区域的系统配置（ConfigureSystem）页面上进行管理操作。

![image-20200519113152771](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113152771.png)

![image-20200519113214949](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113214949.png)

**电子邮件通知**

在全局配置页中，还有一个电子邮件通知（E-mail Notification）的部分，你可以填写信息来设置基本的电子邮件功能。只要你可以收集到电子邮件服务配置的详细信息，这些字段在设置的时候就非常显而易见。值得注意的是，你需要点击右侧的一个高级按钮，之后才能访问某些字段。

![image-20200519113237405](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113237405.png)

![image-20200519113248127](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113248127.png)

**设置构建结果**

![image-20200519113311617](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113311617.png)

![image-20200519113322911](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113322911.png)

![image-20200519113334804](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113334804.png)

### 报告

Jenkins使用的许多插件或工具都会为各种任务生成HTML报告。这样的任务包括代码分析、代码覆盖率和单元测试报告等。其中一些工具（如SonarQube和JaCoCo）甚至可以和Jenkins任务输出做定制集成。这些工具通常采用视觉元素的形式（展示在任务输出页面），例如，徽章、图形以及简单的链接，用户通过点击操作就可以跳转到应用程序本身并查看报告了。

然而，并不是所有的工具都能和Jenkins做到如此程度的集成。这些工具通常只能在工作空间里面创建报告，由用户自行确定位置，以及浏览并查看其中的内容。尤其是当你试图在Jenkins的某一个工作空间中查找报告和/或需要通过多次运行任务来访问报告时，这比在任务输出页面上点击链接获取报告要麻烦一些。

幸运的是，可以使用HTML 发布者插件（HTML Publisher plugin）来帮助我们。这个插件允许你在流水线代码中添加一个步骤来指向HTML报告。它也允许你在任务输出页面上创建自定义链接，并提供长时间保存报告（存档）等选项。

### 发布HTML报告

![image-20200519113700796](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113700796.png)

开始之前，请注意我们有一个target代码块可作为主要参数，其余的都是它的子参数：

allowMissing

此设置与报告缺失时构建是否失败有关。如果设置为false，报告缺失将会使构建失败。

alwaysLinkToLastBuild

如果此设置为true，那么即使当前构建失败，Jenkins也将显示上次成功构建的报告链接。

keepAll

如果此设置为true，那么Jenkins会将所有成功构建的报告归档。否则，Jenkins只会归档最近成功构建的报告。reportDir这是HTML文件相对于Jenkins工作空间的路径。

reportFiles

这是要显示的HTML文件的名称（如果有多个名称，它们应该用逗号分隔）。

reportName

这是你希望在任务输出页面上看到的链接到的报告的名称。

## 访问与安全

### 安全加固Jenkins

在Jenkins 2之前，Jenkins的默认配置是禁用安全性的——不做任何安全检查。这意味着Jenkins在默认情况下是开放的。从Jenkins 2开始，默认已更改为启用安全性。这意味着在你最初开始使用Jenkins的时候，你需要提供一个用户ID和密码。事实上，当你安装Jenkins 2时，必须输入一个在隐藏文件中生成的初始密码，这是安装的步骤之一。你还需要创建一个具有用户ID和密码的初始用户。

![image-20200519113836068](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113836068.png)

![image-20200519113850881](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519113850881.png)

**项目矩阵授权策略。**

此选项是前面章节中描述的“安全矩阵”模型的扩展。在选择此选项后，会为每个项目的配置页添加一个类似的矩阵。这允许每个项目可以以用户/组来配置，因此你可以限制对某些项目的访问，但同时允许访问其他项目。

**标记格式化程序**

Jenkins允许用户在各种文本域中放置自由形式的文本，比如，任务描述、构建描述等。你可以选择将这些格式设置为纯文本或HTML。如果你想使用HTML，请将此选项设置为安全HTML（Safe HTML）。这里的“安全”指的是只允许不会引起黑客攻击安全风险的HTML结构（即以会使系统处于风险中的操作方式进行修改）。安全HTML结构的示例包括基本的粗体、斜体、超链接等。

**代理**

请忽略这个常用的名称，这部分用于配置通过JNLP进程启动的代理的TCP端口。（JNLP是指Java网络启动协议（Java Network Launch Protocol）—— 一种可以在客户端桌面上通过使用远程服务器上的资源来启动应用的方式）。

在通常情况下，这里会使用随机端口。然而，你可以指定一个固定端口替代之而使得它更加安全（只需要为固定端口打开防火墙）。如果你没有使用JNLP功能，你可以在这里使用禁用选项（Disable option）来保证你的系统更加安全。

**防止跨站请求伪造攻击**

跨站请求伪造（CSRF，Cross-Site Request Forgery）是一种可以强制用户在通过身份验证的Web应用程序上执行多余操作的攻击类型。这部分的预防方法是验证Jenkins中的用户是否存在碎屑踪迹（导航历史）。

**CLI**

CLI是一个用于使用命令行接口的传统选项，允许被称为“远程处理”模式。这种模式被认为是不安全的，和其他的一些模式（比如HTTP或SSH）相反。这与它实际使用的编程风格有关，比如Java序列化，会打开安全漏洞和注意事项。这种传统协议也被认为是不易理解的，因此，从Jenkins 2.54开始实施了更新的、更安全的选项。

### Jenkins中的凭证

除了全局地对Jenkins的不同方面进行安全加固外，使用特定、安全的凭证构成了一个安全的Jenkins环境中的关键部分。凭证插件（Credentials plugin）（包含在Jenkins的安装中）提供了对凭证的创建和管理机制，同时也为其他插件提供了用于存储和访问凭证的API。

关于我们所说的“凭证”这个词的意思，在这里有必要多说一句。你也会经常听到它被描述成“密钥”。一般来说，我们指的是提供对受限资源访问权限的一个或多个值。凭证类型的列表如下。

·　用户名和密码——可能被结合起来（当作一项）或者分开使用。·　Docker凭证目录（现在不推荐使用了）。·　Docker主机凭证验证。·　SSH用户名和私钥。·　机密ZIP文件——带凭证的ZIP文件。·　机密文件——带凭证的未压缩文件。·　机密文本——令牌或其他链。·　凭证——带凭证或凭证链的Java密钥库。

### 凭证范围

凭证具有与它们相关联的范围。这是一种表示它们如何才能被暴露的方式。Jenkins使用的主要范围有如下3种。

系统

顾名思义，这个范围与根上下文，也就是Jenkins系统相关联。此范围中的凭证只被暴露给系统和后台任务，并且一般被用于连接到构建节点/代理节点等事情。

全局

全局范围是默认选项，通常用来确保Jenkins中的任务可以使用凭证。此范围中的凭证暴露了它们的上下文和该上下文的所有子上下文。（要记得凭证与上下文相关，上下文表示Jenkins主要部分的层次结构。）

用户

顾名思义，这个范围是每个用户。这意味着只有当Jenkins中的线程作为该用户进行身份验证时，凭证才可用。

### 凭证域

凭证域提供了一种在共同域名下组合凭证集合的方法。通常，公共域名意味着某些期望使用凭证的功能和应用类型。

当定义凭证域时，你需要提供一个域名和一个“规范”，比如一个主机名或URL模式。Jenkins总是有至少一个凭证域——那就是全局域。全局凭证域没有任何规范，因此它适用于Jenkins中的任何东西去使用。

### 凭证提供者

凭证提供者是可以存储和获取凭证的地方。这可以是内部凭证存储，也可以是外部凭证库。

一共有如下这几种标准凭证提供者。

系统凭证提供者（Jenkins凭证提供者）

这会在根上下文中暴露凭证（Jenkins本身）。

两个凭证范围可用：系统和全局。

你可以在Jenkins→凭证→系统中看到这些。

用户凭证提供者

这为用户暴露了每个用户的凭证存储。只有用户范围是可用的，并且一个用户不能看到另一个用户的用户凭证。你可以在Jenkins→<username>→凭证→用户或者Jenkins→人们→<username>→凭证→用户中看到这些凭证。

文件夹凭证提供者

这是由文件夹插件（Folder plugin）提供的。它暴露了每个文件夹的凭证存储并支持文件夹及其任何子文件夹的全局范围。你可以在Jenkins→<folder name>→凭证→文件夹中看到这些凭证。

BlueOcean凭证插件

这个范围的凭证用于Blue Ocean接口和通过它创建/访问的项目。所有这些提供者都可以与凭证域一起使用。

### 凭证存储

凭证存储允许凭证提供者向Jenkins暴露凭证。存储与特定的上下文关联，并且与全局域绑定或者可以使用自定义域。它们可以支持一组凭证域。

内部存储库是实际上存储凭证的地方。外部存储库通常是凭证的扁平化引用或者使用元数据和像查询这样更高级功能的服务。在本章的后面，我们会看一个这样的外部库，叫作Vault。

### 管理凭证

凭证的管理可以通过管理Jenkins菜单下的配置凭证接口完成。在界面上可以允许Jenkins用户使用的选项如下。·　选择那些允许Jenkins使用的凭证提供者来解析凭证。·　选择可以被解析和配置的凭证类型。·　为一个特定的提供者指定可以被包含或者排除的凭证类型。

### 高级凭证：基于角色的访问权限

虽然常见的凭证选项能够处理很多用例，但有时你可能希望使用更细粒度的方法来进行安全加固和授权。一个示范用例将创建一组具有特定权限的新角色，并将角色分配给个人用户。基于角色的授权策略插件（Role-based Authorization Strategy plugin）是为了提供这种功能而设计的。

更具体地说，插件允许定义如下3种角色。

全局角色

能跨越具有权限的项目（如任务、运行和源码管理）的角色。

项目角色

针对任务或者运行类别中的一个项目的角色。

从节点角色

具有管理节点权限的角色。该插件还提供了一个宏工具，以便使用宏作为角色运用的标准。

### Groovy沙箱

虽然脚本批准机制提供了一个良好的签名机制来验证脚本，但是批准每一个来自非管理员的新脚本都会变得费力且不可管理。为了简化这种负担，Jenkins 2还支持在Groovy沙箱中运行脚本的能力。这是通过勾选流水线脚本文本窗口底部的使用Groovy沙箱（Use Groovy Sandbox）复选框来实现的（见图5-54）。

![image-20200519120210593](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519120210593.png)

## 扩展你的流水线

### 可信库和不可信库

Jenkins中的共享库有两种形式：可信的和不可信的。

可信库可以调用/使用Java中的任何方法、Jenkins的API、Jenkins插件、Groovy语言等。由于可信库在它们可以调用和使用的内容方面具有如此广泛的优势，所以管理可在其中添加和更改代码的权限就非常重要了。对可信库进行更新应该需要适当级别的源码版本控制访问和验证。出于同样的原因，可能会造成任何损害的代码应当始终被包含在受监督的可信库中。

不可信代码是被调用和使用限制的代码。调用先前列出的方法类型不允许使用相同的自由度，而且它不能像可信代码那样访问更大的内部对象集合。

不可信代码运行在Groovy沙箱中，它具有一个可“安全”调用的方法列表。在沙箱中运行时，Jenkins会监控库代码是否在尝试调用不存在于安全列表中的任何方法。如果是，则停止执行代码并且必须由管理员授予批准。

### 内部库与外部库

共享库的另一个不同之处是，托管源码控制仓库的位置——不管是在Jenkins实例内部还是在外部源码控制系统中。在大多数情况下内部被视为一种更偏向传统的选项，但出于完整性考虑，此处也包含了相关描述。

**内部库**

这是一种管理库的旧方法，但仍然是一种选择。Jenkins 2包含一个内部Git仓库，可用于存储内部库或测试目的。放置在此库中的任何内容对于所有脚本都是可信的，但推送代码到该库的任何人都必须具有相应的管理权限。

**外部库**

要定义外部库（存储在与Jenkins分开的代码仓库中），你需要提供如下这些信息。·　库的名称（将在脚本中使用它来进行访问）。·　从代码仓库中获取它的方法。·　版本（可选）。

### 从代码仓库获取库

要从源码版本控制中获取库代码，有两个选项可供Jenkins选择：Modern SCM和LegacySCM。

**Modern SCM**

大多数Jenkins SCM插件都已经更新了一个新的API，来拉取一个已命名的版本。当前几乎所有插件都属于这一类型。图6-5显示了此部分配置的示例。在顶部，你可以看到名称和版本，然后选择Modern SCM作为获取方法。

**首选Modern方式**

在某些实例中，一个特定的源码版本控制工具可能会既在Legacy又在Modern选项中显示。在这种情况下，建议使用Modern SCM选项。

## 声明式流水线

### 结构

一个声明式流水线是由一个包含了一些指令和部分的外套代码块组成的。每个部分又可以包含其他的部分、指令和步骤，在某些情况下也会包含条件。代码块、部分以及指令之间的区别多少有点随意，但是既然它们被用在正式文档中，我们会把这些概念以及其他术语定义得更清楚些。

### 代码块

这里的一个代码块实际上指具有开头和结尾的任意一组代码。在Groovy中，其被转化成了一个闭包（一个代码部分，开头和结尾使用｛和｝括起来）。虽然流水线的很多部分严格来说都是代码块，这个术语主要用来描述整个pipeline代码块，其包含了与一个声明式流水线相关的所有代码。就是下面这个样子：

```java
pieline{
    // 声明式语法代码
}
```

### 部分

声明式流水线中的部分是一种方法，用于收集在整个流水线流程的某些特殊点上需要被执行的项目。这些被归组的项目可以包括指令、步骤和条件（在后面的章节中有定义）。随着流水线的执行，系统会寻找这些定义了不同组群和阶段的部分。

当前，有3个区域我们称之为部分。

stages

这个部分封装了用于定义流水线主体和逻辑的所有单个阶段定义（指令）。

steps

这个部分可以在一个阶段定义中封装一组DSL步骤。它用来把一系列的步骤与阶段中的其他项目（比如环境定义）分隔开。

posts

这个部分可以封装一些需要被执行的步骤或者检验的条件，可以定义在流水线的结尾或者一个阶段的结尾。

![image-20200519121746535](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519121746535.png)

### 指令

流水线中的指令可以被认为是一个做任何以下事情的语句或代码块。

定义值

这种类型的一个示例就是agent指令，它允许我们指定一个节点或者容器来运行整个流水线或者一个阶段。如果我们想在节点worker上运行我们的流水线，则可以使用agent （'worker'）。

配置行为

这种类型的一个示例就是triggers指令，它允许我们配置Jenkins多长时间一次去检查源码的更新或者触发我们的流水线。如果我们想每个工作日的早上7点触发我们的流水线，可以使用triggers ｛ cron （'0 7 0 0 1-5'） ｝。

指定要完成的行为

这种类型的一个示例就是stage指令，往往期望它拥有一个包含那些需要被执行的DSL步骤的steps部分。

### 步骤

在流水线的一个阶段中，这个steps标签本身是一个部分头衔。然而，在steps部分内部，我们可以使用任何合法的DSL语句，比如git、 sh、 echo等。你可以把这里的一个步骤认为是相应的这些语句中的一个。

### 条件

![image-20200519121831940](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519121831940.png)

### 构建代码块

通观全局，这些代码块堆积起来如图7-2所示。在这里，每一个方格表示一个特定的部分或指令（由方格上的文本标示），同时它们的位置标明了它们在声明式流水线结构中的位置。例如，pipeline是最外边的代码块，所有的其他部分和指令必须放在这个代码块里面。

在这个结构中，那些虚线环绕的方格是可选的，那些实线方格是必需的。请注意，有些指令可以同时放在流水线级别和阶段级别，它们可能在一个区域中是必需的，而在另一个区域中是可选的。

![image-20200519121903717](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519121903717.png)

### agent

这个agent指令用来指定整个流水线或者一个特定的阶段在哪里运行。这与脚本式流水线中的node指令用法相似。事实上，你把一个代理节点看作一个节点是合理的，除了主节点不是一个代理节点外。

在靠近pipeline代码块的顶部，必须要有一个agent指令用来指定“默认的”执行节点。然而，在单个阶段的开始可以可选地使用一个agent指令，用来指定该阶段中的代码应该在哪里运行。

**标签提醒**

提醒一下，标签就是附在一个节点上的标识符。你可以拥有很多标签，同时相同的标签可以跨多个节点使用去标示一“类”节点。在节点管理下的节点设置中配置标签。一个示例如图7-3所示。

**再谈标签**

请注意，这里<label>不能是正则表达式或者使用通配字符。然而，多个节点/代理可以具有相同的指定的标签。用这种方法，<label>可以匹配一个指定到多个系统上的标签，因此允许从多个选择中选择运行节点。

**标签和自定义工作空间**

代理节点的标签语法新增了一个特性，允许我们为一个流水线或者阶段指定一个自定义的工作空间。具体到代理节点的定义，我们可以包含一个customWorkspace指令，用来指定代理节点所使用的工作空间。语法看起来就像这样：

![image-20200519121948582](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519121948582.png)

**node和label**

![image-20200519122003997](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122003997.png)

**代理节点与Docker**

最后一个代理节点选项，我们来看一下Docker容器。在agent声明中，有两种快速获得Docker镜像的方法——指定一个已经存在的镜像或者从Dockerfile创建一个镜像。或者，可以使用长版本的声明来指定其他元素，比如，容器所使用的节点以及传递给容器的参数。

![image-20200519122030527](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122030527.png)

![image-20200519122041750](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122041750.png)

![image-20200519122053424](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122053424.png)

Docker和非Docker阶段使用相同的节点。还有一个方面与使用Docker代理节点相关。假如你在流水线的顶部定义了一个非Docker的代理节点：

![image-20200519122117008](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122117008.png)

### **environment**

这是声明式流水线中的一个可选指令。顾名思义，这个指令允许你为环境变量指定名称和值，这些环境变量在你的流水线范围内都是可以访问的。像使用agent一样，你可以在主流水线定义和（或）单个阶段中拥有一个environment实例。

在流水线代码块顶部定义的环境，将使流水线所有的步骤都可以访问变量。在一个阶段中定义的环境，将只能在这个阶段范围内访问变量。

![image-20200519122146489](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122146489.png)

### tools

Jenkins用户熟悉使用全局工具配置（Global Tool Configuration）界面配置工具的版本、路径以及安装程序等。一旦完成配置，tools指令可以让我们指定哪些工具需要在我们已经选择的代理节点上自动安装在配置路径下。

### options

这个指令可以用来指定一些属性和值，这些预定义的选项可以应用到整个流水线。这些就是在Jenkins Web表单里一个项目的基本配置中可以设定的事情（除了参数，参数使用单独的部分定义）。你可以把它理解成一个用来设置Jenkins所定义的项目选项的地方。

下面的列表罗列了所有可用的选项，以及简要地说明了它们的含义和用法。

buildDiscarder  保留指定数量的流水线执行，包含控制台输出以及制品。

![image-20200519122354468](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122354468.png)

![image-20200519122415657](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122415657.png)

### triggers

这个指令允许你指定使用什么类型的触发器来启动你的流水线构建。请注意，这些触发器并不适用于多分支流水线、GitHub组织或者Bitbucket 团队/项目等类型的任务，它们都以Jenkinsfile为标志，同时当有代码改动时会通过比如一个webhook来通知Jenkins触发构建。

当前有4种不同的（SCM中性的）触发器可用：cron、pollSCM、upstream以及githubPush。

![image-20200519122511026](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122511026.png)

### parameters

这个指令允许我们为一个声明式流水线指定项目参数。这些参数的输入值可以来自一个用户或者一个API调用。你可以认为这些参数与Web表单中使用此构建是参数化的（This build isparameterized）选项指定的参数是相同类型的参数。

![image-20200519122538021](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122538021.png)

![image-20200519122554603](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122554603.png)

![image-20200519122608585](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122608585.png)

![image-20200519122619514](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122619514.png)

### libraries

在Jenkins 声明式流水线新近引入的指令中有一个libraries指令。这个指令允许声明式流水线导入共享库，因此它们所包含的代码就可以被流水线调用和使用。正如第6章所讨论的，一个共享库就是一些代码的集合，这些代码可以和Jenkins流水线一起工作，而且它们是通过流水线之外的一个源码版本控制管理系统进行存储和访问的。

除了提供一种共享和包含公共代码的方法外，共享库对于声明式流水线来说还有一个有价值的地方，那就是用来封装那些不是声明式的而且通常不能直接在一个流水线中使用的代码（在本章的最后将会有更加详细的讨论）。

![image-20200519122645332](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122645332.png)

### stages

无论是在脚本式流水线中还是在声明式流水线中，Jenkins都希望我们的代码步骤被包含在一个或者多个阶段中。在一个声明式流水线中，单个阶段的集合被封装在stages部分。这使得我们的声明式流水线更加结构化，能够告诉Jenkins这些阶段从哪里开始以及到哪里结束，这与我们所见到的一些流水线级别的指令完全不同。同时s t a g e s是一个必需的部分，而且你至少要在其中有一个阶段。下面是一个流水线部分，用来演示这个语法：

 	![image-20200519122804571](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122804571.png)

**stage**

在stages部分的内部有一些单独的阶段。每一个阶段至少要包含一个名称以及一个或者多个DSL步骤。在一个阶段中，你还可能拥有本地的environment、tools和 agent指令。如果存在相应的全局指令也使用相同的名称定义了值，那么阶段中的指令所定义的值会覆盖全局的那些值。

**steps**

![image-20200519122907129](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122907129.png)

有条件地执行一个阶段。在任何阶段，你都可以有条件地执行。也就是说，你可以让Jenkins基于一个或者多个可以评估为true的条件去决定是否执行该阶段中的步骤。这是一个可选结构，并且不能用在流水线脚本的顶层。

![image-20200519122936432](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122936432.png)

![image-20200519122947980](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519122947980.png)

条件执行使用与、或、非。除了每次使用一个为true的条件外，我们还可以使用逻辑操作来检查多个条件，或者一个相反的条件。声明式流水线语法提供了一些关键字，允许我们将这些等价的与、或、非逻辑运算应用到我们刚才所讨论的3种类型的条件中。

![image-20200519123003369](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123003369.png)

![image-20200519123014458](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123014458.png)

![image-20200519123024020](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123024020.png)

### post

post也是一个既可以在流水线中也可以在阶段中使用的部分。它在两个地方都是可选的。如果在流水线结尾或者阶段结尾有post部分且条件满足的话，它就会被执行。你可以把它想象成传统的Jenkins自由风格类型的任务中的构建后操作。

![image-20200519123042489](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123042489.png)

![image-20200519123627376](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123627376.png)

### script语句

script DSL语句是一个专门在声明式流水线中使用的特殊语句；它允许你定义一个代码块/闭包用来囊括任何非声明式代码。你可能已经猜到了，这个script的名字指的就是脚本式的流水线。

这个语句可以放在你的声明式流水线中的任何你不得不使用非声明式代码的地方。如果你必须使用非声明式代码并且又不打算创建一个共享库的话，这种方法或许是处理这类情况的最佳方法。

![image-20200519123724131](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519123724131.png)

### Blue Ocean接口

在我们离开声明式流水线的细节讨论之前，应当注意另一个方面——声明式流水线更适合与Jenkins新的Blue Ocean接口以及它所提供的可视化流水线编辑器一起工作。CloudBees和Jenkins社区会定期地改进和更新这个可视化界面，同时它也呈现了一种更加有趣的新方式来使用和创建流水线。

Blue Ocean插件和声明式流水线插件紧密结合。声明式流水线的定义良好的结构也使得它本身能够被更好地解析以便可视化展示。这个受限制的结构也使得反向操作更加容易：创建一个简单的可视化界面，结合一些特定的选项，最后能够转变成一个流水线。

## Blue Ocean

除了全新的声明式流水线（Declarative Pipeline）语法之外，Jenkins 2带给我们的核心创新就是一个名为Blue Ocean的图形界面。关于Blue Ocean的功能特性可以汇总如下：

·　提供了图形化的流水线过程展示。

·　提供了图形界面创建新的声明式流水线。

·　在流水线的各阶段中提供了更加细分的过程处理视图，同时支持日志下钻。

·　支持以分支视图管理的多分支流水线（Multibranch Pipeline）项目。

·　支持多分支流水线项目和拉取请求。·　提供了基于源码控制仓库创建流水线的设置向导。

·　提供了流水线编辑器，使用图形化（点击拖曳式）的交互组合方式完成流水线阶段和步骤的编辑。

·　与阶段视图（Stage View）相比，对并发阶段的展现形式更好友好。

·　对尚未支持Blue Ocean定制界面的项目提供了一个回到经典Jenkins界面的链接。

## 集成分析工具

### SonarQube

根据其网站介绍，SonarQube（以前被称为“Sonar”）是一个开放的平台，用于管理一些关键软件领域的代码质量，包括：

·　构架和设计·　注释·　编码规则·　潜在的错误·　重复代码·　单元测试·　复杂度

### 在流水线项目中使用SonarQube

如果我们在传统的流水线中执行过分析任务，想将这个想法应用到Jenkins 2流水线中，那么只需要创建一个分析阶段即可。我们只需选择服务器，传递适当的环境信息，然后调用扫描程序就行了。

幸运的是，如果我们使用的是SonarQube 5.2或更高版本、SonarQube Scanner 2.8或更高版本，同时安装了最新版本的SonarQube插件，那么Jenkins流水线DSL将会简化我们的使用过程。它会提供一个withSonarQubeEnv代码块，允许我们选择要使用的全局配置SonarQube服务器。此外，它甚至可以在代码块内进行与连接细节（与该服务器的全局配置相关联）相关的操作。这简化了调用扫描程序的环境。

![image-20200519130034912](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519130034912.png)

![image-20200519130050671](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519130050671.png)

### 利用SonarQube分析的结果

将SonarQube分析作为流水线流程的一部分，曾经的一个挑战是，获取并利用分析的整体结果，即使用分析结果作为是否允许代码通过/不通过的指标，从而决定是否执行下一部分的流水线。

多年来，我们已经实施并使用了许多解决方案。例如，其中一个解决方案是使用Groovy脚本，该脚本在Jenkins任务中运行，并通过REST API调用访问SonarQube服务器。该自定义脚本从SonarQube获取所需的结果值，然后根据Jenkins任务参数输入的阈值，对它们进行评估判断，以确定是否超出范围。如果存在任何超出参数设置阈值的结果，则脚本将中止Jenkins流程并停止后续任务的执行。

![image-20200519130129020](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519130129020.png)

### 在Jenkins中集成SonarQube的输出

SonarQube提供了多种方法，可以从Jenkins输出自身链接到Jenkins项目分析。这在流水线或任务的阶段视图中最为明显。在图12-16中，你可以看到该项目SonarQube输出的多个链接。在左侧菜单中，你将看到一个名为SonarQube的链接。请注意，它旁边有一个带3条曲线的图标/符号。这个图标/符号也会在构建历史区域中出现，并在#1的行尾显示。点击该标记，你将进入SonarQube应用程序中同一项目的分析页面。最后，SonarQube质量门标签下有一个OK按钮（在项目名称之后），这是指向同一位置的另一个链接。

![image-20200519130157231](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519130157231.png)

### 代码覆盖率：与JaCoCo集成

JaCoCo这个名字是Java Code Coverage的缩写。顾名思义，该工具的目的是为Java源文件提供代码覆盖率的有关信息，实质上，它代表着测试用例运行可以覆盖到的代码量。其通过检测Java类文件来实现。

JaCoCo可以提供有关覆盖率范围的信息，包括：

![image-20200519130301711](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200519130301711.png)

