## Must Know

### 前端三要素

- HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容
- CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式
- JavaScript（行为）：是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行，用于控制网页的行为

### CSS 预处理器

  CSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“**用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用**”。

**常用的 CSS 预处理器有哪些**

- SASS：基于 Ruby，通过服务端处理，功能强大。解析效率高。需要学习 Ruby 语言，上手难度高于 LESS。
- LESS：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用 LESS。

### JavaScript 框架

- jQuery：大家熟知的 JavaScript 框架，优点是简化了 DOM 操作，缺点是 DOM 操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容 IE6、7、8；
- Angular：Google 收购的前端框架，由一群 Java 程序员开发，其特点是将后台的 MVC 模式搬到了前端并增加了**模块化开发**的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代 -> 2代，除了名字，基本就是两个东西；截止发表博客时已推出了 Angular6）
- React：Facebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念 **【虚拟 DOM】** 用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门 **【JSX】** 语言；
- `Vue`：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化） 和 React（虚拟 DOM） 的优点；
- `Axios`：前端通信框架；因为 `Vue` 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能

### MVVM

MVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的**事件驱动编程方式**。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。

MVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下：

- 该层向上与视图层进行双向数据绑定
- 向下与 Model 层通过接口请求进行数据交互

MVVM 已经相当成熟了，主要运用但不仅仅在网络应用程序开发中。当下流行的 MVVM 框架有 `Vue.js`，`AngularJS` 等。

MVVM的核心是数据驱动即ViewModel，ViewModel是View和Model的关系映射。ViewModel类似中转站(Value Converter)，负责转换Model中的数据对象，使得数据变得更加易于管理和使用。MVVM本质就是基于操作数据来操作视图进而操作DOM，借助于MVVM无需直接操作DOM，开发者只需完成包含声明绑定的视图模板，编写ViewModel中有业务，使得View完全实现自动化。

### ![image-20200522025843459](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200522025843459.png)



### View

View 是视图层，也就是用户界面。前端主要由 `HTML` 和 `CSS` 来构建，为了更方便地展现 `ViewModel` 或者 `Model` 层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置模板语言。

### Model

Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的 `接口规则`

### ViewModel

ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。

需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的

- 比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）
- 页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互）

视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层`。由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。

MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新，真正实现 `事件驱动编程`。

View 层展现的不是 `Model` 层的数据，而是 `ViewModel` 的数据，由 `ViewModel` 负责与 `Model` 层交互，这就**完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。**

P2P、P2C 、O2O 、B2C、B2B、 C2C，每天看着这些常见又陌生的名词，如果有人跟你说让你解释它的含义，你们是不是欲言又止了，它的概念意义你真的懂吗?跟着小狂神一起来真正的了解下它们吧！

### P2P

P2P借贷是一种将非常小额度的资金聚集起来借贷给有资金需求人群的一种民间小额借贷模式。P2P是“Peer-to-Peer”的简写，个人对个人的意思，P2P借贷指个人通过第三方平台(P2P公司)在收取一定服务费用的前提下向其他个人提供小额借贷的金融模式。

P2P模式有两种模式，第一种是纯线上模式，是纯粹的P2P，在这种平台模式上纯粹进行信息匹配，帮助资金借贷双方更好的进行资金匹配，但缺点明显，这种线上模式并不参与担保；第二种是债权转让模式，平台本身先行放贷，再将债权放到平台进行转让，很明显能让企业提高融资端的工作效率，但容易出现资金池，不能让资金充分发挥效益。

### O2O

O2O即Online To Offline，即将线下商务的机会与互联网结合在了一起，让互联网成为线下交易的前台。这样线下服务就可以用线上来揽客，消费者可以用线上来筛选服务，还有成交可以在线上结算，很快达到规模。该模式最重要的特点是：推广效果可查，每笔交易可跟踪。

O2O营销模式的核心是在线预付，在线支付不仅是支付本身的完成，是某次消费得以最终形成的唯一标志，更是消费数据唯一可靠的考核标准。其是对提供online服务的互联网专业公司而言，只有用户在线上完成支付，自身才可能从中获得效益。

### B2C

B2C是Business-to-Customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。这种形式的电子商务一般以网络零售业为主，主要借助于互联网开展在线销售活动。B2C即企业通过互联网为消费者提供一个新型的购物环境——网上商店，消费者通过网络在网上购物、在网上支付。

B2C电子商务网站由三个基本部分组成：为顾客提供在线购物场所的商场网站；负责为客户所购商品进行配送的配送系统；负责顾客身份的确认及货款结算的银行及认证系统。

代表网站：一个猫一个狗：天猫——为人服务做平台；京东——自主经营卖产品。

### B2B

B2B，Business-to-Business，企业对企业的电子商务模式，也有写成BTB，是指企业对企业之间的营销关系，它将企业内部网，通过B2B网站与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展。

B2B是指进行电子商务交易的供需双方都是商家(或企业、公司)，她(他)们使用了互联网的技术或各种商务网络平台，完成商务交易的过程。电子商务是现代B2Bmarketing的一种具体主要的表现形式。

阿里巴巴是国内也是全球最大的B2B电子商务网站。是中小企业首选的B2B平台，主要提供“诚信通”服务，但由于所有用户基本上都是“诚信通”客户。所以没有专业的电子商务运营能力和做阿里巴巴的其它推广业务，很难取得显著效果。

### C2C

C2C实际是电子商务的专业用语，是个人与个人之间的电子商务。C指的是消费者，因为消费者的英文单词是Customer(Consumer)，所以简写为C，而C2C即 Customer(Consumer) to Customer(Consumer)。C2C的意思就是个人与个人之间的电子商务。比如一个消费者有一台电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为C2C电子商务。

代表网站： 淘宝网；易趣网；拍拍网。无疑问，淘宝在C2C领域的领先地位暂时还没有人能够撼动。然而，淘宝却也不得不承受这份领先带来的沉甸甸压力。在领先与压力之间，淘宝在奋力往前走。

### P2C

P2C即Production to Consumer简称为商品和顾客，产品从生产企业直接送到消费者手中，中间没有任何的交易环节。是继B2B、B2C、C2C之后的又一个电子商务新概念。在国内叫做：生活服务平台。

P2C具体表现为：如果哪天家乐福、沃尔玛、大中电器等这些零售业巨头也进军电子商务，通过互联网开展商务活动，这种商务活动的可能性一直是存在的，并且随着互联网技术的平台发展，还会向中小企业逐步渗透。

就如大润发超市的飞牛网。P2C把老百姓日常生活当中的一切密切相关的服务信息，如房产、餐饮、交友、家政服务、票务、健康、医疗、保健等聚合在平台上，实现服务业的电子商务化。

### O2O、C2C、B2B、B2C的区别

O2O是：线上交易到线下消费体验；线下营销到线上交易；线下营销到线上交易再到线下消费体验；线上交易或营销到线下消费体验再到线上消费体验四种模式。比如：保险直购O2O，苏宁易购O2O，大众点评O2O等。

C2C就是个人对个人的，比如淘宝的小店铺。B2C是商家对个人，这个就很多了亚马逊、当当、京东等。B2C、C2C很重要的一点是都运用了物流。

B2B是Business to Business是企业间的，比如阿里巴巴。C2C就是我卖东西你来买；我成立个公司卖东西，你来买。O2O就是我成立个公司卖东西你来买但是要你自己来拿。B2B就是你也成立了公司买我公司的东西。

五种常见的电子商务模式对比：B2B、B2C、C2B、C2C、O2O

**（1）B2B模式**

B2B (Business to Business)， 是指商家与商家建立的商业关系。 例如我们在麦当劳中只能够买到可口可乐是因为麦当劳与可口可乐中的商业伙伴的关系。 商家们建立商业伙伴的关系是希望通过大家所提供的东西来形成一个互补的发展机会，大家的生意都可以有利润。例子：阿里巴巴、慧聪。

B2B模式是电子商务中历史最长、发展最完善的商业模式，能迅速的带来利润和回报。它的利润来源于相对低廉的信息成本带来的各种费用的下降，以及供应链和 价值链整合的好处。它的贸易金额是消费者直接购买的10倍。企业间的电子商务成为电子商务的重头。它的应用有通过EDI网络连接会员的行业组织，基于业务 链的跨行业交易集成组织，网上及时采购和供应营运商。

B2B电子商务模式主要有降低采购成本、降低库存成本、节省周转时间、扩大市场机会等优势，目前常见的B2B运营模式主要有垂直B2B（上游和下游，可以形成销货关系）、水平B2B（将行业中相近的交易过程集中）、自建B2B（行业龙头运用自身优势串联整条产业链）、关联行业的B2B（整合综合B2B模式和垂直B2B模式的跨行业EC平台）。B2B的主要盈利模式是：会员收费、广告费用、竞价排名费用、增值服务费、线下服务费、商务合作推广、安询盘付费等。

**（2）B2C模式**

B2C (Business to Consumer)， 就是我们经常看到的供应商直接把商品卖给用户，即“商对客”模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。例如你去麦当劳吃东西就是B2C，因为你只是一个客户。例子：当当、卓越、优凯特。

B2C网站类型主要有综合商城（产品丰富的传统商城EC化）、百货商店（自有库存，销售商品）、垂直商店（满足某种特定的需求）、复合品牌店（传统品牌商的复合）、服务型网店（无形商品的交易）、导购引擎型（趣味购物、便利购物）、在线商品定制型（个性化服务、个性化需求）等。B2C的盈利模式主要是服务费、会员费、销售费、推广费等。

**（3）C2B模式**

C2B (Customer to Business)，比较本土的说法是要约，由客户发布自己要些什么东西，要求的价格是什么，然后由商家来决定是否接受客户的要约。假如商家接受客户 的要约，那么交易成功；假如商家不接受客户的要约，那么就是交易失败。C2B模式的核心，是通过聚合分散分布但数量庞大的用户形成一个强大的采购集团，以此来改变B2C模式中用户一对一出价的弱势地位，使之享受到以大批发商的价格买单件商品的利益。例子：U-deals、当家物业联盟。

C2B模式的一般运行机制是需求动议的发起、消费者群体自觉聚集、消费者群体内部审议、制定出明确的需求计划、选择合适的核心商家或者企业群体、展开集体议价谈判、进行联合购买、消费者群体对结果进行分配、消费者群体对于本次交易结果的评价、消费者群体解散或者对抗。

**（4）C2C模式**

C2C (Customer to Consumer) ，客户之间自己把东西放上网去卖，是个人与个人之间的电子商务。例子：淘宝、拍拍、易趣。C2C的主要盈利模式是会员费、交易提成费、广告费用、排名竞价费用、支付环节费用等。C2C的一般运作流程是：卖方将欲卖的货品登记在社群服务器上、买方透过入口网页服务器得到二手货资料、买方透过检查卖方的信用度后选择欲购买的二手货、透过管理交易的平台分别完成资料记录、买方与卖方进行收付款交易、透过网站的物流运送机制将货品送到买方。

**（5）O2O模式**

O2O即Online To Offline，也即将线下商务的机会与互联网结合在了一起，让互联网成为线下交易的前台。这样线下服务就可以用线上来揽客，消费者可以用线上来筛选服务，还有成交可以在线结算，很快达到规模。该模式最重要的特点是：推广效果可查，每笔交易可跟踪。O2O模式的优势有：充分挖掘线下资源、消费行为更加易于统计、服务方便、优势集中、促使电子商务朝多元化方向发展。

------

还有更多的电子商务模式：

- B2C(经济组织对消费者)
- B2B2C(企业对企业对消费者)
- C2B(T)(消费者集合竞价-团购)
- C2C(消费者对消费者)
- B2F(企业对家庭)
- O2O(网上与网下相结合)
- SaaS(软件服务)
- PaaS(平台服务)
- IaaS(基础服务)
- M-B(移动电子商务)
- B2G(政府采购)
- G2B(政府抛售)
- B2M(面向市场营销商务)
- M2C(生产厂商对消费者)
- BAB(企业-联盟-企业)
- P2C(生活服务平台)
- ABC(代理商-商家-消费者)
- P2P(点对点、渠道对渠道)
- SNS-EC(社会化网络)
- B2S(分享式体验式商务)
- B2B(经济组织对经济组织)
- ............

### 云计算

在介绍那些古怪名词之前，我先介绍一下**云计算**。

以前电脑被发明的时候，还没有网络，每个电脑（PC），就是一个单机。

![1562836647074.png](https://blog.kuangstudy.com/usr/uploads/2019/07/964287038.png)

这台单机，包括CPU、内存、硬盘、显卡等硬件。用户在单机上，安装操作系统和应用软件，完成自己的工作。

后来，有了**网络（Network）**，单机与单机之间，可以交换信息，协同工作。

![1562836668164.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2710188787.png)

再后来，单机性能越来越强，就有了**服务器（Server）**。人们发现，可以把一些服务器集中起来，放在机房里，然后让用户通过网络，去访问和使用机房里的计算机资源。

![1562836743679.png](https://blog.kuangstudy.com/usr/uploads/2019/07/668047030.png)

再再后来，小型网络变成了大型网络，就有了**互联网（Internet）**。小型机房变成了大型机房，就有了**IDC（Internet Data Center，互联网数据中心）**。

当越来越多的计算机资源和应用服务（Application，例如看网页，下电影）被集中起来，就变成了——**“云计算（Cloud Computing）”**。无数的大型机房，就成了“云端”。

![1562836855199.png](https://blog.kuangstudy.com/usr/uploads/2019/07/766174424.png)

是不是觉得太简单？别急，开始深入。

云计算的道理是简单的，说白了，就是把计算机资源集中起来，放在网络上。但是，云计算的实现方式，就非常复杂了。

举个例子，如果你只是在公司小机房摆了一个服务器，开个FTP下载服务，然后用于几个同事之间的电影分享，当然是很简单的。

如果是“双11”的淘宝购物节，全球几十亿用户访问阿里巴巴的淘宝网站，单日几十PB（1PB=1024TB=1024×1024GB）的访问量，每秒几百GB的流量……这个，就不是几根网线几台服务器能解决的了。

这时，需要设计一个**超大容量、超高并发（同时访问）、超快速度、超强安全**的云计算系统，才能满足业务平稳运行的要求。

这才是云计算的复杂之处。

刚才说了，我们把计算机资源放在云端。这个计算机资源，实际上分为好几种层次：

**第一层次**，是最底层的硬件资源，主要包括CPU（计算资源），硬盘（存储资源），还有网卡（网络资源）等。

**第二层次**，要高级一些，我不打算直接使用CPU、硬盘、网卡，我希望你把操作系统（例如Windows、Linux）装好，把数据库软件装好，我再来使用。

**第三层次**，更高级一些，你不但要装好操作系统这些基本的，还要把具体的应用软件装好，例如FTP服务端软件、在线视频服务端软件等，我可以直接使用服务。

这三种层次，就是大家经常听到的**IaaS**、**Paas**、**SaaS**。

![1562836939495.png](https://blog.kuangstudy.com/usr/uploads/2019/07/1898876313.png)

**SaaS**: Software-as-a-Service（软件即服务）

**PaaS**: Platform-as-a-Service（平台即服务）

**IaaS**: Infrastructure-as-a-Service（基础设施即服务）

再补一张图，可能更直观：

![1562836972271.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2034718180.png)

目前主流的云计算服务提供商，例如亚马逊AWS、阿里云、华为云、天翼云、腾讯云，说白了，都是为大家提供以上三个层次的云资源。你想要什么，它们就提供什么。你想要多少，它们就提供多少。

继续，继续。

这么多样化多层次的云计算服务，阿里、华为们又是怎么提供的呢？

难道说，是人工安排？——

如果你要八核CPU、16GB内存、500GB硬盘的服务器，阿里临时安排工程师帮你组装？如果你要装CentOS 7.2（一种类Linux操作系统），MySQL 5.5.60（一种数据库系统），阿里也临时让工程师帮你安装配置？

这显然是不可能的，耗不起人力，也等不起时间。

**于是，就有了各种软件和平台，负责对资源进行快速调用和集中管理。**

### 虚拟化

如果要对物理资源进行管理，第一步，就是**“虚拟化”**。

虚拟化是云计算的基础。简单来说，虚拟化就是在一台物理服务器上，运行多台“虚拟服务器”。这种虚拟服务器，也叫**虚拟机（VM，Virtual Machine）**。

从表面来看，这些虚拟机都是独立的服务器，但实际上，它们共享物理服务器的CPU、内存、硬件、网卡等资源。

![1562837039304.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2592070184.png)

物理机，通常称为“宿主机（Host）”。虚拟机，则称为“客户机（Guest）”。

谁来完成物理资源虚拟化的工作呢？

就是大名鼎鼎的 **Hypervisor** 。

Hypervisor，汉译过来是“超级监督者”，也叫做VMM（Virtual Machine Monitor，虚拟机监视器）。它不是一款具体的软件，而是一类软件的统称。

Hypervisor分为两大类：
第一类，hypervisor直接运行在物理机之上。虚拟机运行在hypervisor之上。第二类，物理机上安装正常的操作系统（例如Linux或Windows），然后在正常操作系统上安装hypervisor，生成和管理虚拟机。

![1562837106869.png](https://blog.kuangstudy.com/usr/uploads/2019/07/929738773.png)

像**VMware**、**KVM**、**Xen**、**Virtual Box**，都属于Hypervisor。

VMware大家应该很熟悉，就是VMware Workstation。学习Linux的话，很多人都是在windows系统下安装WMware，然后创建Linux虚拟机。

![1562837163508.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2739085079.png)

但是，真正厉害的，是 **KVM（kernel-based virtual machine，基于Linux内核的虚拟机）**。它是目前最热门最受追捧的虚拟化方案。

![1562837191248.png](https://blog.kuangstudy.com/usr/uploads/2019/07/1835996430.png)

KVM这样的Hypervisor软件，实际上是提供了一种虚拟化能力，模拟CPU的运行，更为底层。但是它的用户交互并不良好，不方便使用。

于是，为了更好地管理虚拟机，就需要**OpenStack**这样的云管理平台。

![1562837206881.png](https://blog.kuangstudy.com/usr/uploads/2019/07/42515733.png)

关于OpenStack。它有点像个商店，负责管理商品（计算资源、存储资源、网络资源等），卖给用户，但它本身不制造商品（不具备虚拟化能力），它的商品，来自于KVM。当然，如果不用KVM，也可以用Xen等其它hypervisor。

![1562837237509.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2796252013.png)

请记住，上面所说的几个概念，包括VM、KVM、OpenStack等，都主要属于IaaS（基础设施即服务）。这个不难理解吧？

### 容器

继续往下说。

那么，容器是什么呢？大佬们经常说的Docker和K8S，又是什么呢？

前面我们介绍了虚拟化。人们在使用虚拟化一段时间后，发现它存在一些问题：

不同的用户，有时候只是希望运行各自的一些简单程序，跑一个小进程。为了不相互影响，就要建立虚拟机。如果建虚拟机，显然浪费就会有点大，而且操作也比较复杂，花费时间也会比较长。

而且，有的时候，想要迁移自己的服务程序，就要迁移整个虚拟机。显然，迁移过程也会很复杂。

有没有办法**更灵活快速**一些呢？

有，这就引入了**“容器（Container）”**。

容器也是虚拟化，但是属于“轻量级”的虚拟化。它的目的和虚拟机一样，都是为了创造“隔离环境”。但是，它又和虚拟机有很大的不同——虚拟机是操作系统级别的资源隔离，而容器本质上是进程级的资源隔离。

![1562837389565.png](https://blog.kuangstudy.com/usr/uploads/2019/07/1105308499.png)

而大家常听说的**Docker**，就是创建容器的工具，是应用容器引擎。

Docker的中文意思，就是码头工人。而它的LOGO，就是一只鲸鱼背着很多货柜箱。

![1562837408147.png](https://blog.kuangstudy.com/usr/uploads/2019/07/723559656.png)

相比于传统的虚拟机，Docker的优势很明显，它启动时间很快，是秒级，而且对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB，而容器只需要MB级甚至KB级。

除了Docker对容器进行创建之外，我们还需要一个工具，对容器进行**编排**。

这个工具，就是**K8S**。

**K8S**，就是**Kubernetes**，中文意思是舵手或导航员。Kubernetes这个单词很长，所以大家把中间8个字母缩写成8，就成了K8S。

![1562837436081.png](https://blog.kuangstudy.com/usr/uploads/2019/07/2912244687.png)

K8S是一个容器集群管理系统，主要职责是**容器编排（Container Orchestration）**——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。

简单来说，K8S有点像容器的保姆。它负责管理容器在哪个机器上运行，监控容器是否存在问题，控制容器和外界的通信，等等。

通过下面这张K8S系统结构图，就能够看出K8S和容器之间的关系。

![1562837466434.png](https://blog.kuangstudy.com/usr/uploads/2019/07/166358911.png)

除了K8S之外，还有很多种容器管理平台，例如**Compose**，**Marathon**，**Swarm**，**Mesos**等。

Docker和K8S，关注的不再是基础设施和物理资源，而是应用层，所以，就属于PaaS。明白了吧？

### 幂等性

HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源**对于资源本身**应该具有同样的结果（网络超时等问题除外）。也就是说，**其任意多次执行对资源本身所产生的影响均与一次执行的影响相同**。

这里需要关注几个重点：

1. 幂等不仅仅只是一次（或多次）请求对资源没有副作用（比如查询数据库操作，没有增删改，因此没有对数据库有任何影响）。
2. 幂等还包括第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。
3. 幂等关注的是以后的多次请求是否对资源产生的副作用，而不关注结果。
4. 网络超时等问题，不是幂等的讨论范围。

幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。

### SOA架构

面向服务的架构是一种软件体系结构，其应用程序的不同组件通过网络上的通信协议向其他组件提供服务或消费服务，所以也是一种分布式架构。简单来说，SOA是不同业务建立不同的服务，服务之间的数据交互粗粒度可以通过服务接口分级，这样松散耦合提高服务的可重用性，也让业务逻辑变得可组合，并且每个服务可以根据使用情况做出合理的分布式部署，从而让服务变得规范，高性能，高可用。

SOA架构中有两个主要角色：服务提供者（Provider）和服务消费者（Consumer）。阿里开源的Dubbo是SOA的典型实现。

SOA架构的优点：

❑ 把模块拆分，使用接口通信，降低模块之间的耦合度。

❑ 把项目拆分成若干个子项目，不同的团队负责不同的子项目。

❑ 增加功能时只需要增加一个子项目，调用其他系统的接口即可。

❑ 可以灵活地进行分布式部署。

SOA架构的缺点：系统之间的交互需要使用远程通信，接口开发增加工作量。

### APM

APM的全称是Application Performance Management（应用性能管理）。APM致力于监控和管理应用软件性能和可用性，通过监测和诊断复杂应用程序的性能问题，来保证应用程序的良好运行。能够帮助企业实现应用性能的最优化，改进与优化终端用户体验，加速系统开发及交付进程，规避与减小整体投资风险，提高IT生产效率。

## JSR-303的定义

JSR 是Java Specification Requests 的缩写，是指向 JCP(Java Community Process) 提出新增一个标准化技术规范的正式请求。
  任何人都可以提交 JSR，以向 Java 平台增添新的 API 和服务，已审核通过的规范涉及 Java 各个领域，有兴趣可以了解一下。
  Bean Validation 是一个运行时的数据验证框架，为 JavaBean 验证定义了相应的元数据模型和 API。
  默认的元数据是 Java Annotations，当然也可以使用 XML 可以对已存在的元数据信息进行覆盖和扩展。
  在应用中通过使用 Bean Validation 或是你自己定义的 constraint，例如 @NotNull, @Max, @ZipCode， 就可以确保数据模型的正确性。
  constraint 可以注解到字段，getter 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 constraint。

SR-303数据校验分为：普通参数属性验证和对象的验证

#### 普通参数属性验证

类上面配置@Validated，需要校验的参数配置上对应的注解，当方法被调用的时候自动对参数校验，如果校验的结果不通过就抛出异常，会打印配置的message的内容。

@Service
@Validated
public class RedisService {

```JAVA
@Autowired
JedisPool jedisPool;

public <T> T get(@NotNull(message = "rh不能为空") RedisHelper rh, String key, Class<T> clazz) {
	if (clazz == null||key==null||rh==null) {
		return null;
	}
	Jedis jedis = null;
	try {
		jedis = jedisPool.getResource();
		// 生成真正的key
		String realKey = rh.prefix() + key;
		String res = jedis.get(realKey);
		T t = parseStringToBean(res, clazz);
		return t;
	} finally {// 使用完后返回到连接池
		returnToPool(jedis);
	}
}
```

结合AOP环绕增强可以进行异常的处理。

#### 对象的验证

```
@RequestMapping("doLogin")
	@ResponseBody
	Result<String> doLogin(@Valid LoginVo lv,HttpServletResponse resp,BindingResult bindingResult) {
		logger.info(lv.toString());
		if (bindingResult.hasErrors()) {
            List<ObjectError> errorList = bindingResult.getAllErrors();
		}
		String token=sus.login(resp,lv);
		return Result.success(token);
	}
```



```JAVA
package pers.lbw.seckill.vo;

import javax.validation.constraints.NotNull;

import org.hibernate.validator.constraints.Length;

import pers.lbw.seckill.validator.IsMobile;

public class LoginVo {
@NotNull
@IsMobile//我们自定义的验证器
private String mobile;

@NotNull
@Length(min=6)
private String password;

public String getMobile() {
	return mobile;
}
public void setMobile(String mobile) {
	this.mobile = mobile;
}
public String getPassword() {
	return password;
}
public void setPassword(String password) {
	this.password = password;
}
@Override
public String toString() {
	return "LoginVo [mobile=" + mobile + ", password=" + password + "]";
}
```

被校验的参数上用@Valid注解，被校验成参数类中用注解配置规则，当然也可以自定义规则，如上面用的@IsMobile自定义注解
通过bindingResult进行异常的处理。当然也可以用结合AOP环绕增强可以进行异常的处理。

#### 自定义注解

```JAVA
package pers.lbw.seckill.validator;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import javax.validation.Constraint;
import javax.validation.Payload;

@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = { IsMobileValidator.class })//自定义验证器类
public @interface IsMobile {
boolean reqired() default true;

String message() default "手机号码格式错误";//校验非法的时候返回的信息

Class<?>[] groups() default { };

Class<? extends Payload>[] payload() default { };
```

```JAVA
package pers.lbw.seckill.validator;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

import org.springframework.util.StringUtils;

import pers.lbw.seckill.util.ValidatorUtil;
//自定义验证器
//IsMobile是被校验的注解，String是用的时候IsMobile修饰字段的类型，Constraint：约束
//所以这里是对String字段上加了IsMobile注解的进行参数校验
//校验注解在String类上，可以有多个验证器分别校验不同类型，但记得在IsMobile的validatedBy 那也要配置多个
public class IsMobileValidator implements ConstraintValidator<IsMobile,String>{
	private boolean required;
@Override
//这里的value就是注解所在字段的值
public boolean isValid(String value, ConstraintValidatorContext context) {
	if(required) {
		return ValidatorUtil.isMobile(value);//偷个懒，直接用我们之前写的来校验
	}else {
		//非必须的话如果为空按照逻辑的话因该返回true，也就是合法
		if(StringUtils.isEmpty(value)) {
			return true;
		}else {
			return ValidatorUtil.isMobile(value);//偷个懒，直接用我们之前写的来校验
		}
	}
}

@Override
public void initialize(IsMobile constraintAnnotation) {
	required=constraintAnnotation.reqired();
}
```



### JSR-303基本校验规则

空检查
@Null 验证对象是否为null
@NotNull 验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty 检查约束元素是否为NULL或者是EMPTY.

Booelan检查
@AssertTrue 验证 Boolean 对象是否为 true
@AssertFalse 验证 Boolean 对象是否为 false

长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内
@Length(min=, max=) Validates that the annotated string is between min and max included.

日期检查
@Past 验证 Date 和 Calendar 对象是否在当前时间之前，验证成立的话被注释的元素一定是一个过去的日期
@Future 验证 Date 和 Calendar 对象是否在当前时间之后 ，验证成立的话被注释的元素一定是一个将来的日期
@Pattern 验证 String 对象是否符合正则表达式的规则，被注释的元素符合制定的正则表达式，regexp:正则表达式 flags: 指定 Pattern.Flag 的数组，表示正则表达式的相关选项。

数值检查
建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为”“,Integer为null
@Min 验证 Number 和 String 对象是否大等于指定的值
@Max 验证 Number 和 String 对象是否小等于指定的值
@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度
@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度
@Digits 验证 Number 和 String 的构成是否合法
@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。
@Range(min=, max=) 被指定的元素必须在合适的范围内
@Range(min=10000,max=50000,message=”range.bean.wage”)
@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)
@CreditCardNumber信用卡验证
@Email 验证是否是邮件地址，如果为null,不进行验证，算通过验证。
@ScriptAssert(lang= ,script=, alias=)
@URL(protocol=,host=, port=,regexp=, flags=)

### cron表达式详解

Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：

　　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year

　　（2）*Seconds Minutes Hours DayofMonth Month DayofWeek*

　　**一、结构**

　　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份

　　**二、各字段的含义**

| 字段                     | 允许值                                 | 允许的特殊字符             |
| ------------------------ | -------------------------------------- | -------------------------- |
| 秒（Seconds）            | 0~59的整数                             | , - * /   四个字符         |
| 分（*Minutes*）          | 0~59的整数                             | , - * /   四个字符         |
| 小时（*Hours*）          | 0~23的整数                             | , - * /   四个字符         |
| 日期（*DayofMonth*）     | 1~31的整数（但是你需要考虑你月的天数） | ,- * ? / L W C   八个字符  |
| 月份（*Month*）          | 1~12的整数或者 JAN-DEC                 | , - * /   四个字符         |
| 星期（*DayofWeek*）      | 1~7的整数或者 SUN-SAT （1=SUN）        | , - * ? / L C #   八个字符 |
| 年(可选，留空)（*Year*） | 1970~2099                              | , - * /   四个字符         |

　　**注意事项：**

　　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：

　　（1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。

　　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。

　　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 

　　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. 

　　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 

　　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 

　　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。

　　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 

　　（9）#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。

　　**三、常用表达式例子**

　　（1）**0 0 2 1 \* ? \***  表示在每月的1日的凌晨2点调整任务

　　（2）**0 15 10 ? \* MON-FRI**  表示周一到周五每天上午10:15执行作业

　　（3）**0 15 10 ? 6L 2002-2006**  表示2002-2006年的每个月的最后一个星期五上午10:15执行作

　　（4）**0 0 10,14,16 \* \* ?**  每天上午10点，下午2点，4点 

　　（5）**0 0/30 9-17 \* \* ?**  朝九晚五工作时间内每半小时 

　　（6）**0 0 12 ? \* WED**   表示每个星期三中午12点 

　　（7）**0 0 12 \* \* ?**  每天中午12点触发 

　　（8）**0 15 10 ? \* \***   每天上午10:15触发 

　　（9）**0 15 10 \* \* ?**   每天上午10:15触发 

　　（10）**0 15 10 \* \* ? \***   每天上午10:15触发 

　　（11）**0 15 10 \* \* ? 2005**   2005年的每天上午10:15触发 

　　（12）**0 \* 14 \* \* ?**   在每天下午2点到下午2:59期间的每1分钟触发 

　　（13）**0 0/5 14 \* \* ?**   在每天下午2点到下午2:55期间的每5分钟触发 

　　（14）**0 0/5 14,18 \* \* ?**   在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 

　　（15）**0 0-5 14 \* \* ?**   在每天下午2点到下午2:05期间的每1分钟触发 

　　（16）**0 10,44 14 ? 3 WED**   每年三月的星期三的下午2:10和2:44触发 

　　（17）**0 15 10 ? \* MON-FRI**   周一至周五的上午10:15触发 

　　（18）**0 15 10 15 \* ?**   每月15日上午10:15触发 

　　（19）**0 15 10 L \* ?**   每月最后一日的上午10:15触发 

　　（20）**0 15 10 ? \* 6L**   每月的最后一个星期五上午10:15触发 

　　（21）**0 15 10 ? \* 6L 2002-2005**  2002年至2005年的每月的最后一个星期五上午10:15触发 

　　（22）**0 15 10 ? \* 6#3**  每月的第三个星期五上午10:15触发

　　**注：**

　　（1）有些子表达式能包含一些范围或列表

　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”

“*”字符代表所有可能的值

　　因此，“*”在子表达式（月）里表示每个月的含义，“*”在子表达式（天（星期））表示星期的每一天


　　“/”字符用来指定数值的增量 
　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟 
在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样


　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 
　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”

　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 
　　但是它在两个子表达式里的含义是不同的。 
　　在天（月）子表达式中，“L”表示一个月的最后一天 
　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT

　　如果在“L”前有具体的内容，它就具有其他的含义了

　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 
　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题

### 分布式系统

分布式系统（*distributed system*）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。

#### 特征

分布式系统是多个处理机通过通信线路互联而构成的松散耦合的系统。从系统中某台处理机来看，其余的处理机和相应的资源都是远程的，只有它自己的资源才是本地的。至今，对分布式系统的定义尚未形成统一的见解。一般认为，分布式系统应具有以下四个特征：

(1)分布性。分布式系统由多台计算机组成，它们在地域上是分散的，可以散布在一个单位、一个城市、一个国家，甚至全球范围内。整个系统的功能是分散在各个节点上实现的，因而分布式系统具有数据处理的分布性。

(2)自治性。分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。

(3)并行性。一个大的任务可以划分为若干个子任务，分别在不同的主机上执行。 

(4)全局性。分布式系统中必须存在一个单一的、全局的进程通信机制，使得任何一个进程都能与其他进程通信，并且不区分本地通信与远程通信。同时，还应当有全局的保护机制。系统中所有机器上有统一的系统调用集合，它们必须适应分布式的环境。在所有CPU上运行同样的内核，使协调工作更加容易。

优点

(1)资源共享。若干不同的节点通过通信网络彼此互联，一个节点上的用户可以使用其他节点上的资源，如分布式系统允许设备共享，使众多用户共享昂贵的外部设备，如彩色打印机；允许数据共享，使众多用户访问共用的数据库；可以共享远程文件，使用远程特有的硬件设备（如高速阵列处理器），以及执行其他操作。

(2)加快计算速度。如果一个特定的计算任务可以划分为若干个并行运行的子任务，则可把这些子任务分散到不同的节点上，使它们同时在这些节点上运行，从而加快计算速度。另外，分布式系统具有计算迁移功能，如果某个节点上的负载太重，则可把其中一些作业移到其他节点去执行，从而减轻该节点的负载。这种作业迁移称为负载平衡。 

(3)可靠性高。分布式系统具有高可靠性。如果其中某个节点失效了，则其余的节点可以继续操作，整个系统不会因为一个或少数几个节点的故障而全体崩溃。因此，分布式系统有很好的容错性能。 

系统必须能够检测节点的故障，采取适当的手段，使它从故障中恢复过来。系统确定故障所在的节点后，就不再利用它来提供服务，直至其恢复正常工作。如果失效节点的功能可由其他节点完成，则系统必须保证功能转移的正确实施。当失效节点被恢复或者修复时，系统必须把它平滑地集成到系统中。

(4)通信方便、快捷。分布式系统中各个节点通过一个通信网络互联在一起。通信网络由通信线路、调制解调器和通信处理器等组成，不同节点的用户可以方便地交换信息。在低层，系统之间利用传递消息的方式进行通信，这类似于单CPU系统中的消息机制。单CPU系统中所有高层的消息传递功能都可以在分布式系统中实现，如文件传递、登录、邮件、Web浏览和远程过程调用( Remote Procedure call，RPC)。 

分布式系统实现了节点之间的远距离通信，为人与人之间的信息交流提供了很大方便不同地区的用户可以共同完成一个项目，通过传送项目文件，远程登录进入对方系统来运行程序，如发送电子邮件等，协调彼此的工作。 

#### 缺点

尽管分布式系统具备众多优势，但它也有自身的缺点，主要是可用软件不足，系统软件、编程语言、应用程序以及开发工具都相对很少。此外，还存在通信网络饱和或信息丢失和网络安全问题，方便的数据共享同时意味着机密数据容易被窃取。虽然分布式系统存在这些潜在的问题，但其优点远大于缺点，而且这些缺点也正得到克服。因此，分布式系统仍是人们研究、开发和应用的方向。

## RPC

RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。

比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决。

RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）

RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）

RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。

### 常见RPC框架

几种比较典型的RPC的实现和调用框架。

（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol)

和java的原生序列化。

（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。

（3）THRIFT是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。

二、RPC框架实现原理

在RPC框架中主要有三个角色：Provider、Consumer和Registry。如下图所示：

![RPC框架面试总结-RPC原理及实现](http://p1.pstatp.com/large/pgc-image/1540190693339a1cd496dff)

 

节点角色说明：

\* Server: 暴露服务的服务提供方。

\* Client: 调用远程服务的服务消费方。

\* Registry: 服务注册与发现的注册中心。

### RPC调用流程

RPC基本流程图：

![RPC框架面试总结-RPC原理及实现](http://p99.pstatp.com/large/pgc-image/1540190765251e9d1633416)

 

一次完整的RPC调用流程（同步调用，异步另说）如下：

1）服务消费方（client）调用以本地调用方式调用服务；

2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；

3）client stub找到服务地址，并将消息发送到服务端；

4）server stub收到消息后进行解码；

5）server stub根据解码结果调用本地的服务；

6）本地服务执行并将结果返回给server stub；

7）server stub将返回结果打包成消息并发送至消费方；

8）client stub接收到消息，并进行解码；

9）服务消费方得到最终结果。

RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

### 服务注册&发现

![RPC框架面试总结-RPC原理及实现](http://p3.pstatp.com/large/pgc-image/1540190825366a337e549a0)

 

服务提供者启动后主动向注册中心注册机器ip、port以及提供的服务列表；

服务消费者启动时向注册中心获取服务提供方地址列表，可实现软负载均衡和Failover；

### RPC使用到的技术

1、动态代理

生成 client stub和server stub需要用到 Java 动态代理技术 ，我们可以使用JDK原生的动态代理机制，可以使用一些开源字节码工具框架 如：CgLib、Javassist等。

2、序列化

为了能在网络上传输和接收 Java对象，我们需要对它进行 序列化和反序列化操作。

\* 序列化：将Java对象转换成byte[]的过程，也就是编码的过程；

\* 反序列化：将byte[]转换成Java对象的过程；

可以使用Java原生的序列化机制，但是效率非常低，推荐使用一些开源的、成熟的序列化技术，例如：protobuf、Thrift、hessian、Kryo、Msgpack

关于序列化工具性能比较可以参考：jvm-serializers

3、NIO

当前很多RPC框架都直接基于netty这一IO通信框架，比如阿里巴巴的HSF、dubbo，Hadoop Avro，推荐使用Netty 作为底层通信框架。

4、服务注册中心

可选技术：

\* Redis

\* Zookeeper

\* Consul

\* Etcd



## X/Open DTP模型与XA接口

###  X/Open DTP模型

如果一个业务操作涉及对多个数据源进行操作，那么使用原来单一数据库的事务（本地事务）来控制就会不能满足（全局事务）数据的一致性要求。为此X/Open组织定义了DTP（Distributed TransactionProcessing）模型（见图24-1），来规范全局事务处理。

![image-20200225230337211](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200225230337211.png)

如图24-1所示，它定义了几个组件，分别如下：

❑ AP（Application Program，应用程序）：即需要使用分布式事务的应用服务。

❑ RM（Resource Manager，资源管理器）：比如数据库或文件系统，提供对共享资源的访问，保障资源的ACID特性。

❑ TM（Transaction Manager，事务管理器）：主要是给事务分配唯一标识，负责事务的启动、提交及回滚，保障全局事务的原子性。

❑ CRMs（Communication Resource Managers，通信资源管理器）：负责控制分布式应用在TM domain（一组使用同一个TM的实例集合）之内或跨TM domain之间的通信，该通信使用的是OSITP（Open Systems Interconnection Distributed TransactionProcessing）服务。早期规范里并没有提出CRM组件的概念，这是在后面版本的规范中提出的。

❑ 通信协议：即由通信资源管理器支持，在分布式应用使用的通信协议。

### OSI TP与2PC

ISO/IEC 10026-1:1998 Information technology -- Open SystemsInterconnection -- Distributed Transaction Processing标准（简称OSITP），提出了2PC协议（two-phase commit with presumed rollbackprotocol）。该协议具体如下：

在阶段一，事务管理器TM请求所有的资源管理器RM预提交各自的事务分支。资源管理器RM如果能够执行提交，则它会记录相关的事务日志；如果资源管理器RM不能提交事务，则返回失败，同时回滚已经处理的操作，然后释放该事务分支的资源。

在阶段二，事务管理器TM向所有的资源管理器RM发送提交事务或回滚事务分支的请求。如果第一阶段资源管理器RM返回的都是成功，则发送提交事务请求；只要有一个资源管理器RM返回失败，就发送回滚事务请求。在所有资源管理器对共享资源提交或回滚变更之后，反馈执行结果给事务管理器TM，然后事务管理器TM释放占用的相关资源。

成功提交事务的过程如图24-2所示。

![image-20200225230437250](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200225230437250.png)

采用两阶段提交协议，优点就是简单，但是它也有几个缺点，分别如下：

❑ 两阶段的过程都是同步阻塞的，需要等待各个参与者的响应，这会影响分布式事务的操作性能。

❑ 事务管理器TM在整个过程中负责协调管理，如果它自身发生故障，那么资源管理器RM就会阻塞状态，事务无法进行下去。

❑ 在数据一致性方面，如果在阶段二有部分资源管理器RM在收到提交请求后提交了事务，而部分资源管理器RM由于网络异常等未能收到提交事务请求，就会造成数据的不一致。

### XA接口与JTA

XA接口是X/Open DTP在2PC的基础上给事务管理器TM与资源管理器RM之间通信定义的接口。在Java领域，J2EE（Java Enterprise Edition）定义了JTA（Java Transaction API）规范，具体见JSR 907，它遵循X/Open XA接口，是高级版本的API规范。2000年起草了第一版J2EE，最新版是2018年3月份发布的1.3版本。另外还有JTS（Java TransactionService）规范，其定义了更底层的实现事务管理器TM的相关接口，其中包括支持高级别的JTA接口以及标准的CORBA Object TransactionService到Java的映射。JTS对于Java的XA事务规范，类似于JMS（JavaMessage Service）对于Java的消息中间件规范。JTA与JTS的关系如图24-3所示。

![image-20200225230512493](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200225230512493.png)

### Java事务编程接口JTA

满足J2EE规范的容器支持了JTA规范，在纯J2SE领域，Spring Boot官方文档推荐了atomikos、bitronix、narayana这三个组件。这里分别对它们简单介绍一下：

❑ atomikos：希腊语的含义就是原子性，以这个词作为分布式事务组件的名称，用于暗指其可靠的事务管理能力。关于atomikos有开源的版本（TransactionsEssentials），也有增强的收费版（ExtremeTransactions）。TransactionsEssentials最新版本为2018年1月发布的4.0.6版本，相应的spring-boot的组件为spring-boot-starter-jta-atomikos。

❑ bitronix:BTM（Bitronix Transaction Manager）是一款简单但是完整实现了JTA1.1规范的事务管理器，目前该项目已经搁置，最新的版本为2013年9月份发布的2.1.4版本，相应的spring-boot的组件为spring-boot-starter-jta-bitronix。

❑ arayana：它是jboss提供的一款分布式事务管理器，有基于J2EE容器的版本，也有standalone的版本，目前实现了JTA1.2版本的规范，最新版本为2018年7月发布的5.9.0.Final版本。

### 分布式事务TCC模式

2007年Amazon的Pat Helland在Conference on Innovative DatabaseResearch上发表了一篇文章——《Life Beyond DistributedTransactions:An apostate's opinion》，首次提出了解决分布式事务一致性的Tentative Operations、Conf irmation和Cancellation模型。10年后的2017年Pat Helland在acmqueue上发表了一篇同名文章，对前一篇文章的内容进行了概括及更新。其基本定义如下：

❑ Tentative Operation：为了在多个实体之间达成一致，要求一个实体必须能够接受另一个实体对请求执行的不确定性，比如，在发出执行操作请求之后又发出取消该操作的请求。这类后续可能请求取消的操作，就称为Tentative Operation。

❑ Confirmation：如果请求方认为Tentative Operation没问题，那么就可以发出Conf irmation的执行请求，最终确定这个操作。

❑ Cancellation：如果请求方决定撤回Tentative Operation，那么就发出Cancellation的执行请求，取消这个操作。

TCC事务模型总共有Initial、Reserved、Final三个状态：

❑ Initial状态：是最初始的状态，接到Try请求时变成Reserved状态。

❑ Reserved状态：接收Confirm请求时变成Final状态，如果接收Cancel请求或者是等待超时则退回到Initial状态。

❑ Final状态：TCC事务成功状态。

### TCC开源框架

![image-20200225230911585](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200225230911585.png)

##  gRPC

###  gRPC简介

gRPC是谷歌开源的一个高性能的、通用的RPC框架。gRPC和其他RPC一样，客户端应用程序可以直接调用远程服务的方法，就好像调用本地方法一样。RPC框架隐藏了底层的实现细节，包括序列化（XML、JSON、二进制）、数据传输（TCP、HTTP、UDP）、反序列化等，开发人员只需要关注业务本身，而不需要关注RPC的技术细节，这不仅提高了开发效率，从另一维度上看，这也使创建分布式系统变得更简单。

与其他RPC框架一样，gRPC也遵循定义服务（类似于定义接口）的思想。gRPC客户端通过定义方法名、方法参数和返回类型来声明一个可以远程调用的接口方法。在gRPC服务端，实现gRPC客户端定义的接口方法并运行一个gRPC服务器来处理gRPC客户端调用。需要注意的是，gRPC客户端和gRPC服务端共用一个接口方法。

gRPC客户端和服务端可以在各种环境中运行和相互调用。它具有运行环境无关性和开发语言无关性。gRPC通过第三方的开源扩展组件，几乎支持绝大部分的开发语言，包括C++、Java、Python、Go、C#、Node.js、PHP等主流开发语言。如图19-4所示，用Ruby和Android-Java写的gRPC客户端可以通过Proto请求来获取用C++写的gRPC服务端的Proto响应。这种与语言无关的RPC框架，更适合开发团队来构建分布式应用，尤其是微服务系统，开发者不需要使用团队固定的开发语言或者陈旧的技术，他们可以自由选择最适合自己的语言和技术，这大大提高了开发效率。

![image-20200225225546900](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200225225546900.png)

### RPC的生命周期

1．一元RPC（Unary RPC）

Unary RPC（一元RPC），是gRPC中最简单的RPC，也是应用最广泛的RPC，客户端发送一个简单的请求，并获取服务端的一个响应。

❑ 一旦客户端调用RPC方法，服务端会接到客户端传输过来的元数据、方法名和过期时间等信息。

❑ 服务端可以选择发送自己的初始元数据（必须在任何响应之前发送），或者不发送这些元数据，等待客户端发送真正的请求消息。

❑ 一旦服务端获得了客户端的请求消息，服务端会根据客户端传过来的消息，执行具体的方法业务逻辑，并包装到响应里面。如果业务逻辑执行成功，响应、状态信息（状态码以及其他的状态信息）和可选的其他的元数据信息一起返回给客户端。

❑ 如果状态码为OK，则客户端将获得响应，一个完整的RPC就完成了。

2．服务端流式RPC

服务端流式RPC与Unary RPC类似，但服务端获取客户端的请求消息后发送的是响应流。在服务端发送完所有的流数据之后，会在响应里面加上状态信息（状态码及其他状态信息）和可选的其他的元数据信息，将之一起返回给客户端。客户端收到服务端的所有响应之后，一个完整的服务端流式RPC就完成了。

3．客户端流式RP

C客户端流式RPC与Unary RPC类似，只不过客户端向服务端发送的是请求流而不是单个请求消息。服务端通常但不一定在收到所有客户端的请求（包括流以及其状态详细信息和可选的尾随元数据）后才发回单个响应，也可以边收到客户端的流消息，边给出响应。

4．双向流式RPC

在双向流式RPC中，客户端可以多次调用服务端的方法，并发送与客户端相关的流数据，服务端可以发送流数据到客户端，也可以等到更多的流数据到达后再发送流数据。客户端和服务端可以按照任何顺序去读取和写入流数据，它们之间完全独立。

调用方法的客户端接收客户端元数据，方法名称和截止日期的服务器再次发起调用。服务端可以再次选择发送其初始元数据，或者等待客户端开始发送请求。例如，服务端可能会等收到所有客户端的消息后再编写响应，或者服务器和客户端可以“ping-pong”：服务器获取请求并发回响应，然后客户端发送另一个基于响应的请求。

5．截止时间/超时

gRPC允许客户端指定它们愿意等待多久再完成RPC的调用，直到RPC以DEADLINE_EXCEEDED错误终止。服务端可以查询特定的RPC是否超时，或者剩余多少时间来完成RPC。

6. RPC终止

在gRPC中，客户端和服务端都会对RPC调用是否成功进行各自独立的本地比较和判断，它们的结论有可能不一致。这意味着，有可能出现在服务端成功完成RPC（“我已发送所有响应！”）但在客户端失败（“响应在我的截止时间后到达！”）的情况。服务端可以决定在客户端发送的所有请求都到达服务端之前终止。

7．取消RPC

客户端或服务端可以随时取消RPC。取消操作会立即终止RPC，之后不再进行任何数据传输。取消不是“撤销”，进行取消操作之前所做的工作不会被回滚。

8．元数据

元数据是指关于特定RPC调用的信息（例如认证细节），以键值对列表的形式出现，其中键是字符串，值通常也是字符串（也可以是二进制数据）。元数据对gRPC本身是不透明的，它允许客户端提供与服务端调用相关的信息，反之亦然。对元数据的访问取决于具体开发语言。

9．管道

gRPC管道（Channels）提供了与指定主机和端口上的gRPC服务端的连接，这个连接在创建客户端时生成，客户端和服务端就可以通过管道来进行数据传输了。客户端可以指定管道的相关参数来修改gRPC的默认行为，例如打开或者关闭消息压缩。管道具有状态，包括已连接和空闲的状态。gRPC如何处理、关闭管道取决于具体开发语言，例如有些语言允许查询管道的状态，而有些语言没有提供这样的方法。

## Service Mesh

### Service Mesh

Service Mesh是用于处理服务与服务之间通信的专用基础设施层；在具有复杂拓补结构的现代云原生服务间，它负责请求的可靠交付。在具体实践中，Service Mesh通常实现为一系列的轻量级网络代理，这些代理与应用程序代码一起部署，对应用程序是透明的。

![image-20200314225047767](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200314225047767.png)

Service Mesh的数据平面能够支撑很多服务治理逻辑，如服务发现、流量控制（路由、负载均衡）、请求熔断、安全通信、Metric和链路追踪和重试功能。

1．服务发现

以微服务模式运行的应用变更非常频繁，应用实例的频繁增加减少带来的问题是如何精确地发现新增实例，以及避免将请求发送给已不存在的实例上。Service Mesh可以提供简单、统一、平台无关的多种服务发现机制，如基于DNS、K/V键值对存储的服务发现机制。

2．动态路由

随着服务提供商以提供高稳定性、高可用性及高SLA服务为主要目标，为了实现所述目标，出现了各种应用部署策略，尽可能从技术手段上达到无服务中断部署，以此避免变更导致服务的中断和稳定性降低，例如Blue/Green部署、Canary部署，但实现这些高级部署策略通常非常困难。如果可以轻松地将应用流量从一个版本切到另外一个版本，或者从一个数据中心到另外一个数据中心进行动态切换，甚至可以通过一个中心控制层控制多少比例的流量被切换，那么ServiceMesh提供的动态路由机制和特定的部署策略（如Blue/Green部署）结合起来，实现上述目标更加容易。

3．负载均衡

运行环境中微服务实例通常处于动态变化状态，可能经常出现个别实例不能正常提供服务、处理能力减弱、卡顿等现象。由于所有请求对Service Mesh来说是可见的，因此可以通过提供高级负载均衡算法来实现更加智能、高效的流量分发，降低延时，提高可靠性。

4．请求熔断

动态的环境中服务实例中断或不健康导致服务中断的情况可能会经常发生，这就要求应用或其他工具具有快速监测并从负载均衡池中移除不提供服务实例的能力，这种能力也称为熔断，以此使得应用无须消耗更多不必要的资源而不断地尝试，而是快速失败或降级，甚至这样可避免一些潜在的关联性错误。Service Mesh可以很容易地实现基于请求和连接级别的熔断机制。

5．安全通信

无论何时，安全在整个公司、业务系统中都有着举足轻重的位置，也是非常难以实现和控制的部分。在微服务环境中，不同的服务实例间的通信变得更加复杂，那么如何保证这些通信在安全、授权情况下进行非常重要。通过将安全机制如TLS加解密和授权实现在Service Mesh上，不仅可以避免在不同应用中的重复实现，而且很容易在整个基础设施层更新安全机制，甚至无须对应用做任何操作。

6. Metric和链路追踪

Metric是指服务各种运行指标信息，如调用量、成功率、耗时等；而链路追踪是指服务调用的整体链路信息，如链路拓扑、服务依赖。Service Mesh对整个基础设施层的可见性使得它不仅可以暴露单个服务的运行数据，而且可以暴露整个集群的运行数据，因此可以很轻易地从Service Mesh中获取服务的Metric统计信息和服务调用的链路信息。

7．重试

网络环境的异常复杂和服务质量的多变性，服务调用总会存在超时、失败的情况，在这些情况下，重试是能够增加服务质量的一种措施。在Service Mesh中加上重试功能，不仅可以避免将其嵌入业务代码，而且该重试逻辑还可以配置最后期限，使得应用允许一个请求的最长生命周期，防止无限期重试。

