## RabbitMQ基础

### 消息中间件

消息中间件（Message-oriented middleware，MOM）是一种软件或硬件基础设施，通过它可以在分布式系统中发送和接收消息。RabbitMQ通过高级路由和消息分发功能巧妙地实现了这一角色，即使需要满足广域网（Wide Area Network，WAN）环境下实现可靠性所应达到的容错条件，分布式系统也可以很容易与其他系统进行互连。

### RabbitMQ

RabbitMQ是目前市面上应用相当广泛的分布式消息中间件，在企业级应用、微服务系统中充当着重要的角色。它可以通过异步通信等方式降低应用系统接口层面的整体响应时间。除此之外，RabbitMQ在一些典型的应用场景和业务模块处理中具有重要的作用，比如业务服务模块解耦、异步通信、高并发限流、超时业务和数据延迟处理等。

RabbitMQ作为一款能实现高性能存储分发消息的分布式中间件，具有异步通信、服务解耦、接口限流、消息分发和业务延迟处理等功能，在实际生产环境中具有很广泛的应用，其特性可以概括为如图5.2所示。

![image-20200325210244350](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200325210244350.png)

### AMQP

RabbitMQ的很多强大功能和灵活性来自于AMQP规范。不像HTTP和SMTP协议，AMQP规范不仅定义了一种网络协议，同时也定义了服务器端的服务和行为。这些信息就是高级消息队列（Advanced Message Queuing，AMQ）模型。针对代理服务器软件，AMQ模型在逻辑上定义了三种抽象组件用于指定消息的路由行为：

■ 交换器（Exchange），消息代理服务器中用于把消息路由到队列的组件。

■ 队列（Queue），用来存储消息的数据结构，位于硬盘或内存中。

■ 绑定（Binding），一套规则，用于告诉交换器消息应该被存储到哪个队列。

### 交换器

交换器是AMQ模型定义的三种组件之一。一个交换器接收发送到RabbitMQ中的消息并决定把它们投递到何处。交换器定义消息的路由行为，通常这需要检查消息所携带的数据特性或者包含在消息体内的各种属性。

RabbitMQ拥有多种交换器类型，每一种类型具备不同的路由行为。另外，它还提供了一种可用于自定义交换器的插件架构。图1.9展示了发布者发布消息到RabbitMQ中，然后通过交换器进行消息路由的逻辑视图。

![image-20200524140156355](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524140156355.png)

### 队列

队列负责存储接收到的消息，同时也可能包含如何处理消息的配置信息。队列可以把消息只存储在内存中，也可以存储在硬盘中，然后以先进先出（FIFO）的顺序进行投递。

### 绑定

AMQ模型使用绑定（binding）来定义队列和交换器之间的关系。在RabbitMQ中，绑定或绑定键（binding-key）即告知一个交换器应该将消息投递到哪些队列中。对于某些交换器类型，绑定同时告知交换器如何对消息进行过滤从而决定能够投递到队列的消息。

当发布一条消息到交换器时，应用程序使用路由键（routing-key）属性。路由键可以是队列名称，也可以是一串用于描述消息、具有特定语法的字符串。当交换器对一条消息进行评估以决定路由到哪些合适的队列时，消息的路由键就会和绑定键进行比对（见图1.10）。换句话说，绑定键是绑定队列到交换器的粘合剂，而路由键则是用于比对的标准。

![image-20200524140234915](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524140234915.png)

## AMQ协议与Rabbit进行交互

作为一种AMQP代理服务器，RabbitMQ提供了一套严格的通信方式，即在与核心产品进行通信的各个方面几乎都采用了远程过程调用（Remote Procedure Call，RPC）模式。远程过程调用是计算机之间的一种通信方式，它允许一台计算机在另一台计算机上执行一段程序或者一个方法。

### 启动会话

当与AMQP交互时，这个问候语就是协议头（protocol header），由客户端发送给服务器。这个问候语不应该被认为是一个请求，但是与其余的会话不同，这并不是一个命令。RabbitMQ通过Connection.Start命令响应问候语来启动命令/响应序列，而客户端则使用Connection.StartOk响应帧来响应RPC请求（见图2.1）。

![image-20200524140928795](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524140928795.png)

### 调整正确的信道

在概念上与双向无线电的信道类似，AMQP规范定义了与RabbitMQ进行通信的信道。双向无线电使用无线电波作为它们之间的连接并传输信息。在AMQP中，信道使用协商的AMQP连接作为相互传输信息的渠道，而且它们将传输过程与其他正在进行中的会话隔离开来，这点也和双向无线电信道类似。一个AMQP连接可以有多个信道，允许客户端和服务器之间进行多次会话。从技术上讲，这被称为多路复用（multiplexing），对于执行多个任务的多线程或异步应用程序来说，它非常有用。

### AMQP RPC帧结构

与C++、Java和Python等语言中的面向对象编程概念非常相似，AMQP使用类和方法在客户端和服务器之间创建公共语言，这些类和方法被称为AMQP命令（AMQP commands）。AMQP中的类定义了一个功能范围，每个类都包含执行不同任务的方法。在连接协商过程中，RabbitMQ服务器发送一个Connection.Start命令，然后编组成一个帧并发送给客户端。如图2.2所示，Connection.Start命令由两个组件组成：AMQP类（Class）和方法（Method）。

![image-20200524141223551](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524141223551.png)

### AMQP帧组件

当使用命令与RabbitMQ进行交互时，执行这些命令所需的所有参数被封装在一个称为帧的数据结构中，帧对数据进行编码以便传输。帧为命令及其参数提供了一种有效的方式，用于在网络上进行编码和分隔。你可以把帧想象成一列火车上的货箱。概括来讲，货箱都具有相同的基本结构，但是因所包含的内容而异。低层的AMQP帧也是如此。如图2.3所示，低层AMQP帧由五个不同的组件组成：

● 帧类型● 信道编号● 以字节为单位的帧大小● 帧有效载荷● 结束字节标记（ASCII值206）

![image-20200524141256755](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524141256755.png)

低层AMQP帧的头部是三个字段，这三个字段组合起来被称为帧头（frame header）。第一个字段是指示帧类型的单个字节，第二个字段指定帧的信道，第三个字段携带帧有效载荷的字节大小。帧头和结束字节标记合在一起创建了帧的基本结构。

在帧内部，位于头部之后和结束字节标记之前的内容就是帧的有效载荷。就像货车上的货箱能够保护自身内部物品一样，帧的设计也是为了保护其携带内容的完整性。

### 帧类型

AMQP规范定义了五种类型的帧：协议头帧、方法帧、内容头帧、消息体帧及心跳帧。每种帧类型都有明确的目的，而有些帧的使用频率比其他的要高很多。

■ 协议头帧用于连接到RabbitMQ，仅使用一次。

■ 方法帧携带发送给RabbitMQ或从RabbitMQ接收到的RPC请求或响应。

■ 内容头帧包含一条消息的大小和属性。

■ 消息体帧包含消息的内容。

■ 心跳帧在客户端与RabbitMQ之间进行传递，作为一种校验机制确保连接的两端都可用且在正常工作。

### 将消息编组成帧

我们使用方法帧、内容头帧和消息体帧向RabbitMQ发布消息。发送的第一个帧是携带命令和执行它所需参数（如交换器和路由键）的方法帧。方法帧之后是内容帧，包含内容头和消息体。内容头帧包含消息属性以及消息体大小。AMQP的帧大小有一个上限，如果消息体超过这个上限，消息内容将被拆分成多个消息体帧。这些帧始终以相同的顺序发送：方法帧、内容头帧以及一个或多个消息体帧（见图2.4）。

![image-20200524141950572](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524141950572.png)

### 方法帧结构

方法帧携带着构建RPC请求所需的类、方法以及相关参数。在图2.5中，携带Basic.Publish命令的方法帧中包含着描述该命令的二进制打包数据以及与其一起传递的请求参数。前两个字段是Basic类和Publish方法的数字表示。这些字段后面跟着交换器和路由键的字符串值。正如前文所述，这些属性告知RabbitMQ如何路由消息。Mandatory标志则告知RabbitMQ消息必须投递成功，否则发布消息的过程就应该是失败的。

![image-20200524142107674](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142107674.png)

### 内容头帧

在方法帧之后发送的消息头除了告知RabbitMQ该消息的大小之外，还有很多其他数据。如图2.6所示，消息头帧还包含消息的各种属性，为RabbitMQ服务器和可能接收它的任何应用程序提供了对消息的描述。这些属性存储在Basic.Properties映射表中，可能包含描述消息内容的数据，也可能是完全空白。大多数客户端库将预先填充一小部分字段，比如内容类型和投递模式。

![image-20200524142151047](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142151047.png)

### 消息体帧

消息的消息体帧与正在传输的数据类型无关，并且可能包含二进制或文本数据。无论你是发送如JPEG图片的二进制数据，或是序列化之后的JSON、XML格式数据，消息体帧都是消息中包含实际消息数据的结构（见图2.7）。

<img src="C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142210757.png" alt="image-20200524142210757" style="zoom:150%;" />

### 声明交换器

和队列一样，交换器在AMQ模型中是一等公民。因此，它们在AMQP规范中都有自己的类。使用Exchange.Declare命令可以创建交换器，该命令提供了定义交换器名称和类型的参数，以及用于消息处理的其他元数据。

![image-20200524142423673](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142423673.png)

### 声明队列

![image-20200524142439185](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142439185.png)

### 绑定队列到交换器

![image-20200524142503431](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142503431.png)

### 发布消息到RabbitMQ

![image-20200524142700795](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142700795.png)

###  从RabbitMQ中消费消息

一旦发布的消息被路由并保存到一个或多个队列中，我们能讨论的就只剩下如何对它进行消费。要消费RabbitMQ队列中的消息，消费者应用程序通过发出Basic.Consume命令来订阅RabbitMQ中的队列。像其他同步命令一样，服务器将使用Basic.ConsumeOk进行响应，让客户端知道它将打开闸门并释放一大堆消息，或者至少是一两条消息。在RabbitMQ的说明文档中，消费者将开始通过我们已经熟悉的一种格式接收消息，这种格式包括对应的Basic.Deliver方法和它们的内容头以及消息体帧（见图2.12）。

![image-20200524142752668](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142752668.png)

消费消息时，有几个设置可以让RabbitMQ知道你想如何接收它们。其中的一个设置是用Basic.Consume命令中的no_ack参数。当设置该参数为true时，RabbitMQ将连续发送消息直到消费者发送一个Basic.Cancel命令或消费者断开连接为止。如果no_ack标志被设置为false，则消费者必须通过发送Basic.Ack RPC请求来确认收到的每条消息（见图2.13）。

![image-20200524142813066](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524142813066.png)

## 消息属性详解

### 合理使用属性

![image-20200524143608387](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524143608387.png)

在消息标准化的发展过程中，AMQP消息属性为定义和传输消息元数据提供了一个有用的起点。这些元数据反过来使读者能够在消息发布者和消费者之间建立严格的契约。包含content-type、消息类型（type）、timestamp和应用程序标识（app-id）在内的很多属性都已经被证明是非常有用的，它们不仅可用于在过程中实现数据一致性，也适合于日常操作。简而言之，通过使用消息属性，你可以创建自描述消息，类似于将XML视为一种自描述数据标记语言。

■ 使用content-type属性让消费者知道如何解释消息体。

■ 使用content-encoding属性来指示消息体使用某种特殊的方式进行压缩或编码。

■ 填充message-id和correlation-id来唯一标识消息和消息响应，用于在工作流程中实现消息跟踪。

■ 利用timestamp属性减少消息大小，并创建一个规范定义来描述消息创建时间。

■ 使用expiration属性表明消息过期。

■ 告诉RabbitMQ使用delivery-mode将消息写入磁盘或内存队列。

■ 使用app-id和user-id来帮助追踪出现问题的消息发布者应用程序。

■ 使用type属性来定义发布者和消费者之间的契约。

■ 使用reply-to属性实现响应消息的路由。

■ 使用headers映射表定义自由格式的属性和实现RabbitMQ路由。

![image-20200524143748597](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524143748597.png)

## 消息路由模式

也许RabbitMQ最强大之处就在于其灵活性：它能根据消息发布方提供的路由信息，将消息路由到不同的队列中去。不论是将消息发往单个队列、多个队列、交换器，还是另一个由交换器插件提供的外部源，RabbitMQ的路由引擎能始终保持极快的速度和高度灵活性。即使在一开始构建应用时并不需要这些复杂的路由逻辑，正确选择交换器类型仍然会对应用架构造成举足轻重的影响。

交换器的四种基本类型，以及架构类型：

■ Direct交换器。■ Fanout交换器。■ Topic交换器。■ Headers交换器。

### 通过direct交换器路由消息

![image-20200524144254343](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524144254343.png)

### 通过fanout交换器广播消息

Direct交换器使得队列能够接收特定目的的消息。不同于此，fanout交换器并不作区分。所有发往fanout交换器的消息会被投递到所有绑定到该交换器上的队列中。由于RabbitMQ不需要在投递消息时检测路由键，这将带来可观的性能优势。不过由于缺少选择性，这意味着所有绑定到fanout交换器上的队列对应的消费者都应当能够消费发送过来的消息。

### 使用topic交换器有选择地路由消息

类似于direct交换器，topic交换器会将消息路由至匹配路由键的任一队列中。但是通过采用句点分隔的形式，队列可以通过使用基于通配符的模式匹配的方式来绑定到路由键上。通过使用星号（*）和井号（＃）字符，你可以在同一时刻匹配路由键的特定部分，甚至是多个部分。星号将会匹配路由键中下一个句点前的所有字符，而井号键将会匹配接下来所有的字符，包括句点。

![image-20200524144805062](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524144805062.png)

● image.new.profile——用于表示包含新资料图片的消息。● image.new.gallery——用于表示包含新相册图片的消息。● image.delete.profile——用于表示含有删除资料图片的元数据的消息。● image.delete.gallery——用于表示含有删除相册图片的元数据的消息。● image.resize——用于表示要求调整图片大小的消息。

### 使用headers交换器有选择地路由消息

第四种內建交换器类型是headers交换器。它通过采用消息属性中的headers表支持任意的路由策略。绑定至headers交换器的队列会向Queue.Bind参数中传入键值对数组以及x-match参数。x-match参数是字符串类型，可以设置为any或者all。如果将其设置为any，同时headers表中的值匹配了任何一个绑定值的话，消息就会被路由过去。如果将x-match设置为all的话，那么所有传入Queue.Bind中的参数值必须全部匹配才行。这并不排除消息在headers表中拥有额外的键值对。

![image-20200524144853795](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524144853795.png)

## RabbitMQ集群

### 集群简介

![image-20200524145138316](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524145138316.png)

### 集群节点类型

RabbitMQ集群有多种不同类型的节点，它们的行为都不太一样。当向集群中添加节点时，它必须是磁盘节点或者内存节点。

磁盘节点将集群的运行时状态会同时存储在内存和磁盘上。在RabbitMQ中，运行时状态包括集群、队列、绑定、虚拟主机、用户和策略等信息的定义。鉴于此，如果集群拥有大量的运行时状态时，相比内存节点，磁盘节点更容易受到磁盘I/O问题的困扰。

**节点类型和消息持久化**

不论是哪种节点类型都不会影响消息持久化的行为。当通过消息属性delivery-mode将一条消息标记为持久化时，这条消息会被写入磁盘，而无关乎节点类型。因此，考虑磁盘I/O对RabbitMQ集群节点的影响就显得很尤为重要。如果需要持久化消息的话，你应当提供磁盘子系统来满足集群节点中队列写入速度的要求。

**节点类型与崩溃行为**

当节点或者集群崩溃时，在磁盘节点启动并重新加入集群时，会被用来重建集群的运行时状态。而对于内存节点来说，当加入集群时则不会包含任何运行时状态数据。在重新加入集群时，集群中的其他节点会将诸如队列定义等信息发送给它。

当创建集群时，确保至少存在一个磁盘型节点。当集群中拥有多个磁盘节点时，就能在发生硬件故障时更加游刃有余。但多个磁盘节点在某些故障场景下是一把双刃剑。当集群中有多个节点故障时，如果其中两个磁盘节点对集群的共享状态不一致，那么你在尝试将集群恢复至先前状态时就会遇到困难。假设这事儿真的发生了，那么建议将整个集群关闭并按顺序重启节点。启动那个持有最多正确状态数据的磁盘节点，然后再添加其他节点。

**状态节点**

如果你使用rabbitmq管理插件的话，那么你可以使用另一种节点类型，即统计节点（Statsnode）。它只能和磁盘节点搭配使用。统计节点负责收集集群中每个节点的全部统计数据和状态数据。在任意时刻，一个集群只能有一个统计节点。对于大型集群设置来说，最佳策略是配置专门的管理节点，即主磁盘节点和统计节点，并再至少配置一个磁盘节点以提供故障转移的能力（见图7.3）。

![image-20200524145454858](F:\重要文档！！\image-20200524145454858.png)

## 跨集群的消息分发

### 联合交换器和联合队列

联合交换器允许发往上游节点交换器的消息被透明地发送至下游节点中相同名称的交换器上。而联合队列则允许下游节点扮演上游节点中共享队列的消费者角色，为多个下游节点提供了轮询（round-robin）消费消息的能力。

联合插件的新增功能：基于队列的联合（queue-based federation），为扩展队列能力提供了方法。它对于解决消息通信负载特别有用。某些队列可能会有大量的消息发布活动，而消息消费的速度相对慢，或者受到了限流的影响。当采用联合队列时，消息发布者使用上游节点（集群），将消息发往下游节点的所有同名队列中（见图8.5）。

![image-20200524150204358](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200524150204358.png)

## 使用替代协议

### MQTT

消息队列遥测传输（MQ Telemetry Transpor，即MQTT）协议是一种轻量级的消息通信协议，在移动端应用中应用广泛。RabbitMQ通过插件机制来支持它。来自IBM的AndyStanford-Clark和来自Eurotech的Arien Nipper于1999年发明了这款基于发布/订阅模式的MQTT协议。MQTT被设计用来在资源约束的设备以及低带宽的环境下使用，而不必牺牲消息通信的可靠性。虽然没有AMQP那样功能强大，但是随着移动端应用的爆发式增长，MQTT近几年来也风光无限。

### STOMP

STOMP的前身是TMPP。后来Brian McCallister于2005年首次将其明确为面向文本的消息协议（STOMP）。由于参照HTTP进行建模，STOMP成为了简单易读的基于文本的协议。该协议最开始在Apache ActiveMQ中进行了实现。由于奉行简单的原则，STOMP现在支持了多种消息代理服务器实现，并且有大多数流行的编程语言的客户端实现。

STOMP 1.2规范于2012年发布。RabbitMQ支持这一版本（以及上一版本）的STOMP规范。STOMP作为一个插件随RabbitMQ核心包的一部分进行发布。像AMQP和MQTT那样，对STOMP协议的理解有助于你在应用开发过程中建立起自己的观点。

### 通过HTTP进行无状态发布

在某些场景中，AMQP、MQTT、STOMP以及其他有状态协议对于无法维持到RabbitMQ的长久连接的高速消息通信来说十分昂贵。这些协议在进行消息相关的操作之前会有一些连接开销。从性能的角度来看，相对于短连接来说，它们可能不太理想。正是认识到了这一点才导致开发了statelessd。它是一款HTTP转AMQP的消息发布代理。对于客户端应用程序来说，它提供了高性能、发后即忘的消息发布机制，而无需受困于连接状态管理开销。