## MySQL     

### 数据库基础

#### 数据库

数据库（database） 保存有组织的数据的容器（通常是一个文件或一组文件）。

#### 表

表（table） 某种特定类型数据的结构化清单。

表名的唯一性取决于多个因素，如数据库名和表名等的结合。这表示，虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中却可以使用相同的表名。

#### 模式

模式（schema） 关于数据库和表的布局及特性的信息。

#### 列

列（column） 表中的一个字段。所有表都是由一个或多个列组成的。

#### 数据类型

数据类型（datatype） 所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。

#### 主键

主键（primary key）一列（或一组列），其值能够唯一区分表中每个行。

#### SQL语言

SQL语言包含以下4部分。

（1）数据定义语言（DDL）：DROP、CREATE、ALTER等语句。

（2）数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。

（3）数据查询语言（DQL）：SELECT语句。

（4）数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句。

#### OLTP

OLTP也被称为面向交易的处理系统，其基本特征是可以立即将顾客的原始数据传送到计算中心进行处理，并在很短的时间内给出处理结果，这个过程的最大优点是可以即时地处理输入的数据、及时地回答，因此OLTP又被称为实时系统（Real Time System）。

#### OLAP

OLAP的概念最早是由关系数据库之父E.F.Codd博士于1993年提出的，是一种用于组织大型商务数据库和支持商务智能的技术。OLAP数据库分为一个或多个多维数据集，每个多维数据集都由多维数据集管理员组织和设计，以适应用户检索和分析数据的方式，从而更易于创建和使用所需的数据透视表和数据透视图。

#### MySQL的基础架构

![image-20200226133243967](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200226133243967.png)

MySQL由以下几部分组成：□ 连接池组件□ 管理服务和工具组件□ SQL接口组件□ 查询分析器组件□ 优化器组件□ 缓冲（Cache）组件□ 插件式存储引擎□ 物理文件

一般来说，可将数据库的应用类型分为OLTP（OnLine Transaction Processing ，联机事务处理）和OLAP（OnLine Analysis Processing，联机分析处理）两种。OLTP是传统关系型数据库的主要应用，其主要面向基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。

### 数据库的基本操作

#### 创建数据库

```sql
CREATE DATABASE 数据库名;
```

#### 删除数据库

```sql
drop database <数据库名>;
```

### 数据表的基本操作

#### 创建数据表

```sql
CREATE TABLE table_name (column_name column_type);
```

####  删除数据表

```sql
DROP TABLE table_name ;
```

#### 修改数据表

```sql
ALTER TABLE xxx RENAME xxx;
```

#### 表的约束

![image-20200220204208839](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200220204208839.png)

### 数据类型和运算符

#### 整数类型

![image-20200321043220909](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043220909.png)

![image-20200321043237141](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043237141.png)

#### 浮点数类型和定点数类型

![image-20200321043256376](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043256376.png)

![image-20200321043313528](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043313528.png)

#### 日期与时间类型

![image-20200321043336110](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043336110.png)

YEAR类型占用1字节，并且在定义时可以指定显示的宽度为YEAR（4）或YEAR（2），对于YEAR（4），其显示年份的范围为1901～2155；对于YEAR（2），其显示年份的范围为1970～2070。在YEAR（2）的设置下，00～69代表2000～2069年。

TIME类型占用3字节，显示的范围为“-838：59：59”～“838：59：59”。有人会奇怪为什么TIME类型的时间可以大于23。因为TIME类型不仅可以用来保存一天中的时间，也可以用来保存时间间隔，同时这也解释了为什么TIME类型也可以存在负值。和DATETIME类型一样，TIME类型同样可以显示微秒时间，但是在插入时，数据库同样会进行截断操作。

#### 星期数的问题

可以使用MySQL数据库内置的WEEKDAY函数来取得星期几。WEEKDAY函数返回值为0～6，0代表Monday，1代表Tuesday，……，6代表Sunday；也可以使用DAYOFWEEK函数，其返回值为1～7，1代表Sunday，2代表Monday，……，7代表Saturday；还可以直接使用DAYNAME函数来返回日期具体的名称。

#### 文本字符串类型

![image-20200321043433928](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043433928.png)

![image-20200321043448968](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043448968.png)

CHAR和VARCHAR的区别如下：●　CHAR是固定长度字符，VARCHAR是可变长度字符。

●　CHAR会自动删除插入数据的尾部空格，VARCHAR不会删除尾部空格。CHAR是固定长度，所以它的处理速度比VARCHAR的速度要快，但是它的缺点是浪费存储空间，所以对存储不大但在速度上有要求的可以使用CHAR类型，反之可以使用VARCHAR类型来实现。

存储引擎对于选择CHAR和VARCHAR的影响：

●　对于MyISAM存储引擎：最好使用固定长度的数据列代替可变长度的数据列。这样可以使整个表静态化，从而使数据检索更快，用空间换时间。

●　对于InnoDB存储引擎：使用可变长度的数据列，因为InnoDB数据表的存储格式不分固定长度和可变长度，因此使用CHAR不一定比使用VARCHAR更好，但由于VARCHAR是按照实际的长度存储的，比较节省空间，所以对磁盘I/O和数据存储总量比较好。

#### 二进制字符串类型

![image-20200321043528390](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043528390.png)

#### 常见运算符介绍

![image-20200321043708687](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043708687.png)

![image-20200321043732871](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043732871.png)

![image-20200321043758691](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043758691.png)

![image-20200321043813354](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321043813354.png)

### MySQL函数

#### 数学函数

绝对值函数ABS(x)和返回圆周率的函数PI() 。 ABS(X)返回X的绝对值。PI()返回圆周率π的值。默认的显示小数位数是6位。

平方根函数SQRT(x)和求余函数MOD(x,y)。SQRT(x)返回非负数x的二次方根。MOD(x,y)返回x被y除后的余数，MOD()对于带有小数部分的数值也起作用，它返回除法运算后的精确余数。

获取整数的函数CEIL(x)、CEILING(x)和FLOOR(x)。CEIL(x)和CEILING(x)的意义相同，返回不小于x的最小整数值，返回值转化为一个BIGINT。FLOOR(x)返回不大于x的最大整数值，返回值转化为一个BIGINT。

获取随机数的函数RAND()和RAND(x)。RAND(x)返回一个随机浮点值v，范围在0到1之间（0 ≤ v ≤ 1.0）。

函数ROUND(x)、ROUND(x,y)和TRUNCATE(x,y)。ROUND(x)返回最接近于参数x的整数，对x值进行四舍五入。ROUND(x,y)返回最接近于参数x的数，其值保留到小数点后面y位，若y为负值，则将保留x值到小数点左边y位。TRUNCATE(x,y)返回被舍去至小数点后y位的数字x。若y的值为0，则结果不带有小数点或不带有小数部分。若y设为负数，则截去（归零）x小数点左起第y位开始后面所有低位的值。

符号函数SIGN(x)。SIGN(x)返回参数的符号，x的值为负、零或正时返回结果依次为-1、0或1。

幂运算函数POW(x,y)、POWER(x,y)和EXP(x)。POW(x,y)或者POWER(x,y)函数返回x的y次乘方的结果值。EXP(x)返回e的x乘方后的值。

对数运算函数LOG(x)和LOG10(x)。LOG(x)返回x的自然对数，x相对于基数e的对数。LOG10(x)返回x的基数为10的对数。

角度与弧度相互转换的函数RADIANS(x)和DEGREES(x)。RADIANS(x)将参数x由角度转化为弧度。DEGREES(x)将参数x由弧度转化为角度。

正弦函数SIN(x)和反正弦函数ASIN(x)。SIN(x)返回x正弦，其中x为弧度值。ASIN(x)返回x的反正弦，即正弦为x的值。若x不在-1到1的范围之内，则返回NULL。

余弦函数COS(x)和反余弦函数ACOS(x)。COS(x)返回x的余弦，其中x为弧度值。ACOS(x)返回x的反余弦，即余弦是x的值。若x不在-1~1的范围之内，则返回NULL。

正切函数、反正切函数和余切函数。TAN(x)返回x的正切，其中x为给定的弧度值。ATAN(x)返回x的反正切，即正切为x的值。COT(x)返回x的余切。

#### 字符串函数

CHAR_LENGTH(str)返回值为字符串str所包含的字符个数。

LENGTH(str)返回值为字符串的字节长度，使用utf8（UNICODE的一种变长字符编码，又称万国码）编码字符集时，一个汉字是3字节，一个数字或字母算1字节。

CONCAT(s1,s2,…)返回结果为连接参数产生的字符串，或许有一个或多个参数。如有任何一个参数为NULL，则返回值为NULL。如果所有参数均为非二进制字符串，则结果为非二进制字符串。如果自变量中含有任一二进制字符串，则结果为一个二进制字符串。

INSERT(s1,x,len,s2)返回字符串s1，其子字符串起始于x位置和被字符串s2取代的len字符。如果x超过字符串长度，则返回值为原始字符串。假如len的长度大于其他字符串的长度，则从位置x开始替换。若任何一个参数为NULL，则返回值为NULL。

LOWER (str)或者LCASE (str)可以将字符串str中的字母字符全部转换成小写字母。UPPER(str)或者UCASE(str)可以将字符串str中的字母字符全部转换成大写字母。

LEFT(s,n)返回字符串s开始的最左边n个字符。RIGHT(s,n)返回字符串str最右边的n个字符。

LPAD(s1,len,s2)返回字符串s1，其左边由字符串s2填补到len字符长度。假如s1的长度大于len，则返回值被缩短至len字符。

LTRIM(s)返回字符串s，字符串左侧空格字符被删除。RTRIM(s)返回字符串s，字符串右侧空格字符被删除。

REPEAT(s,n)返回一个由重复的字符串s组成的字符串，字符串s的数目等于n。若n<=0，则返回一个空字符串。若s或n为NULL，则返回NULL。

SPACE(n)返回一个由n个空格组成的字符串。

STRCMP(s1,s2)：若所有的字符串均相同，则返回0；若根据当前分类次序，第一个参数小于第二个，则返回-1；其他情况返回1。

SUBSTRING(s,n,len)带有len参数的格式，从字符串s返回一个长度与len字符相同的子字符串，起始于位置n。也可能对n使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的n字符，即倒数第n个字符，而不是字符串的开头位置。

LOCATE(str1,str)、POSITION(str1 IN str)和INSTR(str, str1)3个函数的作用相同，返回子字符串str1在字符串str中的开始位置。

REVERSE(s)将字符串s反转，返回的字符串的顺序和s字符串顺序相反。

#### 日期和时间函数

CURDATE()和CURRENT_DATE()函数的作用相同，将当前日期按照‘YYYY-MM-DD’或YYYYMMDD格式的值返回，具体格式根据函数在字符串或是数字语境中而定。

CURRENT_TIMESTAMP()、LOCALTIME()、NOW()和SYSDATE() 4个函数的作用相同，均返回当前日期和时间值，格式为‘YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS，具体格式根据函数在字符串或数字语境中而定。

MONTH(date)函数返回date对应的月份，范围值为1~12。

DAYNAME(d)函数返回d对应的工作日的英文名称，例如Sunday、Monday等。DAYOFWEEK(d)函数返回d对应的一周中的索引（位置，1表示周日，2表示周一，...，7表示周六）。

DAYOFYEAR(d)函数返回d是一年中的第几天，范围是1~366。

YEAR(date)返回date对应的年份，范围是1970~2069。

QUARTER(date)返回date对应的一年中的季度值，范围是1~4。

EXTRACT(type FROM date)函数所使用的时间间隔类型说明符与DATE_ADD()或DATE_SUB()的相同，但它从日期中提取一部分，而不是执行日期运算。

TIME_TO_SEC(time)返回已转化为秒的time参数。转换公式为：小时*3600+分钟*60+秒。

#### 条件判断函数

IF(expr, v1, v2)：如果表达式expr是TRUE(expr <> 0 and expr <> NULL)，则返回值为v1；否则返回值为v2。IF()的返回值为数字值或字符串值，具体情况视其所在语境而定。

IFNULL(v1,v2)：假如v1不为NULL，则IFNULL()的返回值为v1；否则其返回值为v2。IFNULL()的返回值是数字或者字符串，具体情况取决于其所在的语境。

CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2]…[ELSE rn+1] END：如果expr值等于某个vn，则返回对应位置THEN后面的结果；如果与所有值都不相等，则返回ELSE后面的rn+1。

#### 系统信息函数

VERSION()返回指示MySQL服务器版本的字符串。这个字符串使用utf8字符集。

CONNECTION_ID()返回MySQL服务器当前连接的次数，每个连接都有各自唯一的ID。

processlist命令的输出结果显示了有哪些线程在运行，不仅可以查看当前所有的连接数，还可以查看当前的连接状态、帮助识别出有问题的查询语句等。

#### 加密函数

MD5(str)为字符串算出一个MD5 128比特校验和。该值以32位十六进制数字的二进制字符串形式返回，若参数为NULL，则会返回NULL。

SHA(str)从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。

SHA2(str, hash_length)使用hash_length作为长度，加密str。hash_length支持的值为224、256、384、512和0。其中，0等同于256。

#### 其他函数

FORMAT(x,n)将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串的形式返回。若n为0，则返回结果函数不含小数部分。

CONV(N, from_base, to_base)函数进行不同进制数间的转换。返回值为数值N的字符串表示，由from_base进制转化为to_base进制。如有任意一个参数为NULL，则返回值为NULL。自变量N被理解为一个整数，但是可以被指定为一个整数或字符串。最小基数为2，最大基数为36。

INET_ATON(expr)给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数。地址可以是4或8bit地址。

GET_LOCK(str,timeout)设法使用字符串str给定的名字得到一个锁，超时为timeout秒。若成功得到锁，则返回1；若操作超时，则返回0；若发生错误，则返回NULL。假如有一个用GET_LOCK()得到的锁，当执行RELEASE_LOCK()或连接断开（正常或非正常）时，这个锁就会解除。

RELEASE_LOCK(str)解开被GET_LOCK()获取的、用字符串str所命名的锁。若锁被解开，则返回1；若该线程尚未创建锁，则返回0（此时锁没有被解开）；若命名的锁不存在，则返回NULL。若该锁从未被GET_LOCK()的调用获取，或锁已经被提前解开，则该锁不存在。

IS_FREE_LOCK(str)检查名为str的锁是否可以使用（换言之，没有被封锁）。若锁可以使用，则返回1（没有人在用这个锁）；若这个锁正在被使用，则返回0；出现错误，则返回NULL（诸如不正确的参数）。

IS_USED_LOCK(str)检查名为str的锁是否正在被使用（换言之，被封锁）。若被封锁，则返回使用该锁的客户端的连接标识符（connection ID）；否则，返回NULL。

### 查询数据

#### 基本查询语句

![image-20200220135317653](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200220135317653.png)

可以看到一共有11个步骤，最先执行的是FROM操作，最后执行的是LIMIT操作。每个操作都会产生一张虚拟表，该虚拟表作为一个处理的输入。这些虚拟表对用户是透明的，只有最后一步生成的虚拟表才会返回给用户。如果没有在查询中指定某一子句，则将跳过相应的步骤。接着我们来具体分析查询处理的各个阶段：

1）FROM： 对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积（Cartesian product），产生虚拟表VT1。

2）ON： 对虚拟表VT1应用ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2中。

3）JOIN：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHTOUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止。

4）WHERE：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中。

5）GROUP BY：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5。

6）CUBE | ROLLUP：对表VT5进行CUBE或ROLLUP操作，产生表VT6。

7）HAVING：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。

8）SELECT：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中。

9）DISTINCT：去除重复数据，产生虚拟表VT9。

10）ORDER BY：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。

11）LIMIT：取出指定行的记录，产生虚拟表VT11，并返回给查询用户。

#### 内连接

内连接查询出的数据是两张表的交集，即上图中红色所表示的部分。

![img](https://img-blog.csdnimg.cn/20190428195855745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2MzY1Nw==,size_16,color_FFFFFF,t_70)

#### 左外连接

左外链接如图中红色部分的内容，即包含左边表的全部行（不管右边的表中是否存在与它匹配的行），和右边表中全部匹配的行。

![img](https://img-blog.csdnimg.cn/2019042820015418.png)

#### 右外链接

右外链接如图中红色部分的内容，即包含右边表的全部行（不管左边的表中是否存在与它匹配的行），和左边表中全部匹配行。

![img](https://img-blog.csdnimg.cn/20190428200348262.png)

 

#### 左连接

左连接如图中红色部分的内容，查询出左表独有的数据

![img](https://img-blog.csdnimg.cn/20190428202047132.png)



 解析:其实上图就是在左外连接的基础上进行的，左外连接得到了左表，但是左表里还包含了一部分左右表都具有相同数据的区             域，这时需要将这部分相同数据去掉，去除的条件就是B.key IS NULL 

![img](https://img-blog.csdnimg.cn/20190428202956754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2MzY1Nw==,size_16,color_FFFFFF,t_70)

#### 右连接

 如果看懂了上面的左连接，那么右连接大同小异，就是查询出右表独有的数据

![img](https://img-blog.csdnimg.cn/20190428203321516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2MzY1Nw==,size_16,color_FFFFFF,t_70)

#### 全连接

(Mysql中不支持下图写法)

查询出左右两表的所有数据 

![img](https://img-blog.csdnimg.cn/20190428220851953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2MzY1Nw==,size_16,color_FFFFFF,t_70)



但是！MySQL中并不支持这种写法，所以只能通过别的方法。

A、B的所有也就是A的独有、B的独有 和A、B的共同拥有的数据

Mysql中可以使用：

```sql
 select * from Table A left join Table B on A.Key = B.Key       (找出A的所有)
 union  (去重)
 select * from Table A right join Table B on A.Key = B.Key     （找出B的所有)     
```

#### 全外连接

(Mysql中不支持下图写法)

左右表的共有数据之外的数据查询 

![img](https://img-blog.csdnimg.cn/20190428221109788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk2MzY1Nw==,size_16,color_FFFFFF,t_70)

筛选出对于A表而言B为空，对于B表而言A为空的

MySQL中也不支持这种写法，所以只能通过别的方法。

其实全外连接也就是A的独有+B的独有

Mysql语法：        

```sql
 select * from Table A left join Table B on A.Key = B.Key  where B.Key is null      (找出A的独有)
 union (去重)
 select * from Table A right join Table B on A.Key = B.Key where A.Key is null    （找出B的独有)
```

#### CROSS JOIN

CROSS JOIN对两个表执行笛卡儿积，返回两个表中所有列的组合。若左表有m行数据，右表有n行数据，则CROSS JOIN将返回m*n行的表。

#### INNER JOIN

通过INNER JOIN用户可以根据一些过滤条件来匹配表之间的数据。在逻辑查询的前三个处理阶段中，INNER JOIN应用前两个阶段，即首先产生笛卡儿积的虚拟表，再按照ON过滤条件来进行数据的匹配操作。INNERJOIN没有第三步操作，即不添加外部行，这是和OUTER JOIN最大的区别之一。也正因为不会添加外部行，指定过滤条件在ON子句和WHERE子句中是没有任何区别的。

#### OUTER JOIN

通过OUTER JOIN用户可以按照一些过滤条件来匹配表之间的数据。与INNER JOIN不同的是，在通过OUTER JOIN添加的保留表中存在未找到的匹配数据。MySQL数据库支持LEFT OUTER JOIN和RIGHT OUTERJOIN。与INNER关键字一样，可以省略OUTER关键字。

#### NATURAL JOIN

ANSI SQL还支持NATURAL JOIN，即自然联接。NATURAL JOIN等同于INNTER JOIN与USING的组合，它隐含的作用是将两个表中具有相同名称的列进行匹配。同样的， NATURAL LEFT（RIGHT） JOIN等同于LEFT（RIGHT） OUTER JOIN与USING的组合。

#### 子查询

带ANY、SOME关键字的子查询

ANY、SOME关键字的子查询ANY和SOME关键字是同义词，表示满足其中任一条件，它们允许创建一个表达式对子查询的返回值列表进行比较，只要满足内层子查询中的任何一个比较条件，就返回一个结果作为外层查询的条件。

带ALL关键字的子查询

ALL关键字与ANY和SOME不同，使用ALL时需要同时满足所有内层查询的条件。例如，修改前面的例子，用ALL关键字替换ANY。ALL关键字接在一个比较操作符的后面，表示与子查询返回的所有值比较为TRUE，则返回TRUE。

带EXISTS关键字的子查询

EXISTS关键字后面的参数是一个任意的子查询，系统对子查询进行运算以判断它是否返回行，如果至少返回一行，那么EXISTS的结果为true，此时外层查询语句将进行查询；如果子查询没有返回任何行，那么EXISTS返回的结果是false，此时外层语句将不进行查询。

带IN关键字的子查询

IN关键字进行子查询时，内层查询语句仅仅返回一个数据列，这个数据列里的值将提供给外层查询语句进行比较操作。

带比较运算符的子查询

在前面介绍的带ANY、ALL关键字的子查询时使用了“>”比较运算符，子查询时还可以使用其他的比较运算符，如“<”“<=”“=”“>=”和“!=”等。

#### 合并查询结果

利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。UNION不使用关键字ALL，执行的时候删除重复的记录，所有返回的行都是唯一的；使用关键字ALL的作用是不删除重复行也不对结果进行自动排序。

```sql
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions]
UNION [ALL | DISTINCT]
SELECT expression1, expression2, ... expression_n
FROM tables
[WHERE conditions];
```

#### 为表和字段取别名

当表名字很长或者执行一些特殊查询时，为了方便操作或者需要多次使用相同的表时，可以为表指定别名，用这个别名替代表原来的名称。

```sql
表名 as 表别名；
列名 as 列别名；
```

#### 使用正则表达式查询

![image-20200321050313683](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321050313683.png)

### 插入、更新与删除数据

#### 插入数据

MySQL 表中使用 **INSERT INTO** SQL语句来插入数据。

```sql
INSERT INTO table_name ( field1, field2,...fieldN )
                       VALUES
                       ( value1, value2,...valueN );
                      
```

#### 更新数据

MySQL中使用UPDATE语句更新表中的记录，可以更新特定的行或者同时更新所有的行。

```sql
UPDATE table_name SET field1=new-value1, field2=new-value2
[WHERE Clause]
```

#### 删除数据

DELETE FROM 命令来删除 MySQL 数据表中的记录。

```sql
DELETE FROM table_name [WHERE Clause]
```

### 索引

#### 索引

索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。使用索引可以快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。

引的优点主要有以下几条：

（1）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。

（2）可以大大加快数据的查询速度，这也是创建索引的主要原因。

（3）在实现数据的参考完整性方面，可以加速表和表之间的连接。

（4）在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间。

增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。

（2）索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。

（3）当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。

#### 索引的分类

MySQL的索引可以分为以下几类：

1．普通索引和唯一索引

普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。唯一索引要求索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。

2．单列索引和组合索引

单列索引即一个索引只包含单个列，一个表可以有多个单列索引。组合索引是指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。

3．全文索引

全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。MySQL中只有MyISAM存储引擎支持全文索引。

4．空间索引

空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOTNULL，空间索引只能在存储引擎为MyISAM的表中创建。

#### 索引的设计原则

1. 选择唯一性索引

   唯一性索引的值是唯一的，可以更快速地通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。

2. 为经常需要排序、分组和联合操作的字段建立索引

   经常需要使用ORDER BY、GROUP BY、DISTINCT和UNINON等操作的字段，排序操作会浪费很多时间，如果为其建立索引，可以有效地避免排序操作。

3. 为经常作为查询条件的字段建立索引

   如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度，为这样的字段建立索引可以提高整个表的查询速度。

4. 限制索引的数目

   索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。

5. 尽量使用数据量少的索引

   如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间多。

6. 尽量使用前缀来索引

   如果索引的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。

7. 删除不再使用或者很少使用的索引

   表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。

#### 创建普通索引

最基本的索引类型，没有唯一性之类的限制，其作用只是加快对数据的访问速度。

```sql
CREATE INDEX indexName ON mytable(username(length)); 
```

#### 创建唯一索引

创建唯一索引的主要原因是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

```sql
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

#### 创建单列索引

单列索引是在数据表中的某一个字段上创建的索引，一个表中可以创建多个单列索引。前面两个例子中创建的索引都为单列索引。

#### 创建组合索引

组合索引是在多个字段上创建一个索引。

#### 创建全文索引

FULLTEXT全文索引可以用于全文搜索。只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列创建索引。索引总是对整个列进行，不支持局部（前缀）索引。

#### 创建空间索引

空间索引必须在MyISAM类型的表中创建，且空间类型的字段必须为非空。

#### 添加和删除索引

```sql
mysql> ALTER TABLE testalter_tbl ADD INDEX (c);
mysql> ALTER TABLE testalter_tbl DROP INDEX c;
```

#### 索引的管理

索引在创建或者删除时，MySQL会先创建一个新的临时表，然后把数据导入临时表，删除原表，再把临时表更名为原表名称。

但是在InnoDB Plugin版本开始，支持快速创建索引。其原理是先在InnoDB上加一个s锁，在创建过程中不需要建表，所以速度会很快。创建过程中由于加了s锁，所以只能进行读操作，不能写操作。

show index form table;是查看表中索引的信息的。

Table:索引所在的表名

Non_unique:非唯一的索引，可以看到primary key 是0，因为必须是唯一的

Key_name:索引名称

Seq_in_index:索引中该列的位置

Column_name:索引的列

Collation:列以什么方式存储在索引中。可以是A或者NULL，B+树索引总是A，即排序的。

Cardinality：表示索引中唯一值的数目的估计值。如果非常小，那么需要考虑是否还需要建立这个索引了。优化器也会根据这个值来判断是否使用这个索引。

Sub_part:是否是列的部分被索引。100表示只索引列的前100个字符。

Packed:关键字如果被压缩。

Null：是否索引的列含有NULL值。

Index_type:索引的类型。InnoDB只支持B+树索引，所以显示BTREE

#### 创建索引的原则

创建索引是我们提高数据库查询数据效率最常用的办法，也是很重要的办法。下面是常见的创建索引的原则。

◎ 选择唯一性索引：唯一性索引一般基于Hash算法实现，可以快速、唯一地定位某条数据。

◎ 为经常需要排序、分组和联合操作的字段建立索引。

◎ 为常作为查询条件的字段建立索引。

◎ 限制索引的数量：索引越多，数据更新表越慢，因为在数据更新时会不断计算和添加索引。

◎ 尽量使用数据量少的索引：如果索引的值很长，则占用的磁盘变大，查询速度会受到影响。

◎ 尽量使用前缀来索引：如果索引字段的值过长，则不但影响索引的大小，而且会降低索引的执行效率，这时需要使用字段的部分前缀来作为索引。

◎ 删除不再使用或者很少使用的索引。

◎ 尽量选择区分度高的列作为索引：区分度表示字段值不重复的比例。

◎ 索引列不能参与计算：带函数的查询不建议参与索引。◎ 尽量扩展现有索引：联合索引的查询效率比多个独立索引高。

### 视图

#### 视图

视图是从一个或者多个表中导出的，视图的行为与表非常相似，但视图是一个虚拟表。在视图中用户可以使用SELECT语句查询数据，以及使用INSERT、UPDATE和DELETE修改记录。从MySQL 5.0开始可以使用视图，视图可以使用户操作方便，而且可以保障数据库系统的安全。

视图是一个虚拟表，是从数据库中一个或多个表中导出来的表。

视图还可以从已经存在的视图的基础上定义。视图一经定义便存储在数据库中，与其相对应的数据并没有像表那样在数据库中再存储一份，通过视图看到的数据只是存放在基本表中的数据。对视图的操作与对表的操作一样，可以对其进行查询、修改和删除。当对通过视图看到的数据进行修改时，相应的基本表的数据也要发生变化；同时，若基本表的数据发生变化，则这种变化也可以自动反映到视图中。

#### 创建存储过程和函数

存储程序可以分为存储过程和函数。在MySQL中，创建存储过程和函数使用的语句分别是CREATE PROCEDURE和CREATE FUNCTION。使用CALL语句来调用存储过程，只能用输出变量返回值。函数可以从语句外调用（引用函数名），也能返回标量值。存储过程也可以调用其他存储过程。

创建存储过程，需要使用CREATE PROCEDURE语句。

创建存储函数，需要使用CREATE FUNCTION语句。

#### 视图的作用

与直接从数据表中读取相比，视图有以下优点：

1．简单化看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化它们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。

2．安全性通过视图用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特定行和特定的列上。通过视图，用户可以被限制在数据的不同子集上：

（1）使用权限可被限制在基表的行的子集上。

（2）使用权限可被限制在基表的列的子集上。

（3）使用权限可被限制在基表的行和列的子集上。

（4）使用权限可被限制在多个基表的连接所限定的行上。

（5）使用权限可被限制在基表中的数据的统计汇总上。

（6）使用权限可被限制在另一视图的一个子集上，或是一些视图和基表合并后的子集上。

3．逻辑数据独立性视图可帮助用户屏蔽真实表结构变化带来的影响。

#### 创建视图

要在MySQL中创建一个新视图，可以使用`CREATE VIEW`语句。 在MySQL中创建视图的语法如下：

```sql
CREATE 
   [ALGORITHM = {MERGE  | TEMPTABLE | UNDEFINED}]
VIEW [database_name].[view_name] 
AS
[SELECT  statement]
SQL
```

#### 查看视图

查看视图是查看数据库中已存在的视图的定义。查看视图必须要有SHOW VIEW的权限，MySQL数据库下的user表中保存着这个信息。查看视图的方法包括DESCRIBE、SHOW TABLESTATUS和SHOW CREATE VIEW。

#### 修改视图

修改视图是指修改数据库中存在的视图，当基本表的某些字段发生变化的时候，可以通过修改视图来保持与基本表的一致性。MySQL中通过CREATE OR REPLACE VIEW语句和ALTER语句来修改视图。

#### 更新视图

更新视图是指通过视图来插入、更新、删除表中的数据，因为视图是一个虚拟表，其中没有数据。通过视图更新的时候都是转到基本表上进行更新的，如果对视图增加或者删除记录，实际上是对其基本表增加或者删除记录。

INSERT、UPDATE和DELETE。

当视图中包含有如下内容时，视图的更新操作将不能被执行：（1）视图中不包含基表中被定义为非空的列。（2）在定义视图的SELECT语句后的字段列表中使用了数学表达式。（3）在定义视图的SELECT语句后的字段列表中使用聚合函数。（4）在定义视图的SELECT语句中使用了DISTINCT、UNION、TOP、GROUP BY或HAVING子句。

#### 删除视图

当视图不再需要时，可以将其删除。删除一个或多个视图可以使用DROP VIEW语句。

### MySQL存储过程

#### 存储过程

整个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。

常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。

一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。

存储过程通常有如下优点：

1) 封装性

存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。

2) 可增强 SQL 语句的功能和灵活性

存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。

3) 可减少网络流量

由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。

4) 高性能

存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。

5) 提高数据库的安全性和数据的完整性

使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。

#### 创建存储过程

可以使用 CREATE PROCEDURE 语句创建存储过程。

```sql
CREATE PROCEDURE <过程名> ( [过程参数[,…] ] ) <过程体>
[过程参数[,…] ] 格式
[ IN | OUT | INOUT ] <参数名> <类型>
```

语法说明如下：

1) 过程名

存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。

2) 过程参数

存储过程的参数列表。其中，`<参数名>`为参数名，`<类型>`为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。

MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。

3) 过程体

存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条 SQL 语句，则可以省略 BEGIN-END 标志。

#### 修改存储过程

MySQL 中通过 ALTER PROCEDURE 语句来修改存储过程。

```sql
ALTER PROCEDURE 存储过程名 [ 特征 ... ]
```

`特征`指定了存储过程的特性，可能的取值有：

- CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。
- NO SQL 表示子程序中不包含 SQL 语句。
- READS SQL DATA 表示子程序中包含读数据的语句。
- MODIFIES SQL DATA 表示子程序中包含写数据的语句。
- SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。
- DEFINER 表示只有定义者自己才能够执行。
- INVOKER 表示调用者可以执行。
- COMMENT 'string' 表示注释信息。

#### 删除存储过程

MySQL 中使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：

```sql
DROP { PROCEDURE | FUNCTION } [ IF EXISTS ] <过程名>
```

语法说明如下：

- 过程名：指定要删除的存储过程的名称。
- IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。

### MySQL触发器

#### 触发器

触发器（trigger）是一个特殊的存储过程，不同的是，执行存储过程要使用CALL语句来调用，而触发器的执行不需要使用CALL语句来调用，也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MySQL自动调用。

触发程序的优点如下：

- 触发程序的执行是自动的，当对触发程序相关表的数据做出相应的修改后立即执行。
- 触发程序可以通过数据库中相关的表层叠修改另外的表。
- 触发程序可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。

在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。

1) INSERT 触发器

在 INSERT 语句执行之前或之后响应的触发器。

使用 INSERT 触发器需要注意以下几点：

- 在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。
- 在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。
- 对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。

2) UPDATE 触发器

在 UPDATE 语句执行之前或之后响应的触发器。

使用 UPDATE 触发器需要注意以下几点：

- 在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。
- 在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。
- 在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。
- OLD 中的值全部是只读的，不能被更新。

3) DELETE 触发器

在 DELETE 语句执行之前或之后响应的触发器。

使用 DELETE 触发器需要注意以下几点：

- 在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。
- OLD 中的值全部是只读的，不能被更新。

#### 创建触发器

```sql
CREATE <触发器名> < BEFORE | AFTER >
<INSERT | UPDATE | DELETE >
ON <表名> FOR EACH Row<触发器主体>
```

语法说明如下。

1) 触发器名

触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。

2) INSERT | UPDATE | DELETE

触发事件，用于指定激活触发器的语句的种类。

注意：三种触发器的执行时间如下。

- INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。
- DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。
- UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。

3) BEFORE | AFTER

BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。

4) 表名

与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。

5) 触发器主体

触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。

6) FOR EACH ROW

一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。

#### 修改和删除触发器

与其他 MySQL)数据库对象一样，可以使用 DROP 语句将触发器从数据库中删除。

语法格式如下：

```sql
DROP TRIGGER [ IF EXISTS ] [数据库名] <触发器名>
```

语法说明如下：

1) 触发器名

要删除的触发器名称。

2) 数据库名

可选项。指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库。

3) 权限

执行 DROP TRIGGER 语句需要 SUPER 权限。

4) IF EXISTS

可选项。避免在没有触发器的情况下删除触发器。

### 用户管理

#### 创建用户

可以使用 CREATE USER 语句来创建一个或多个 MySQL 账户，并设置相应的口令。

语法格式：

```sql
CREATE USER <用户名> [ IDENTIFIED ] BY [ PASSWORD ] <口令>
```

语法说明如下：

1) <用户名>

指定创建用户账号，格式为 'user_name'@'host_name'。这里`user_name`是用户名，`host_name`为主机名，即用户连接 MySQL 时所在主机的名字。若在创建的过程中，只给出了账户的用户名，而没指定主机名，则主机名默认为“%”，表示一组主机。

2) PASSWORD

可选项，用于指定散列口令，即若使用明文设置口令，则需忽略`PASSWORD`关键字；若不想以明文设置口令，且知道 PASSWORD() 函数返回给密码的散列值，则可以在口令设置语句中指定此散列值，但需要加上关键字`PASSWORD`。

3) IDENTIFIED BY子句

用于指定用户账号对应的口令，若该用户账号无口令，则可省略此子句。

4) <口令>

指定用户账号的口令，在`IDENTIFIED BY`关键字或`PASSWOED`关键字之后。给定的口令值可以是只由字母和数字组成的明文，也可以是通过 PASSWORD() 函数得到的散列值。

#### 修改用户

可以使用 RENAME USER 语句修改一个或多个已经存在的 MySQL 用户账号。

语法格式：

```sql
RENAME USER <旧用户> TO <新用户>
```

语法说明如下：

- <旧用户>：系统中已经存在的 MySQL 用户账号。
- <新用户>：新的 MySQL 用户账号。

#### 修改用户口令

可以使用 SET PASSWORD 语句修改一个用户的登录口令。

语法格式：

```sql
SET PASSWORD [ FOR <用户名> ] =
{
    PASSWORD('新明文口令')
    | OLD_PASSWORD('旧明文口令')
    | '加密口令值'
}
```

语法说明如下。

- FOR 子句：可选项。指定欲修改口令的用户。
- PASSWORD('新明文口令')：表示使用函数 PASSWORD() 设置新口令，即新口令必须传递到函数 PASSWORD() 中进行加密。
- 加密口令值：表示已被函数 PASSWORD() 加密的口令值。

#### 删除用户

MySQL数据库中可以使用 DROP USER 语句来删除一个或多个用户账号以及相关的权限。

语法格式：

```sql
DROP USER <用户名1> [ , <用户名2> ]…
```

使用 DROP USER 语句应该注意以下几点：

- DROP USER 语句可用于删除一个或多个 MySQL 账户，并撤销其原有权限。
- 使用 DROP USER 语句必须拥有 MySQL 中的 MySQL 数据库的 DELETE 权限或全局 CREATE USER 权限。
- 在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”。

#### 用户授权

对于新建的 MySQL 用户，必须给它授权，可以用 GRANT 语句来实现对新建用户的授权。

语法格式：

```sql
GRANT
<权限类型> [ ( <列名> ) ] [ , <权限类型> [ ( <列名> ) ] ]
ON <对象> <权限级别> TO <用户>
其中<用户>的格式：
<用户名> [ IDENTIFIED ] BY [ PASSWORD ] <口令>
[ WITH GRANT OPTION]
| MAX_QUERIES_PER_HOUR <次数>
| MAX_UPDATES_PER_HOUR <次数>
| MAX_CONNECTIONS_PER_HOUR <次数>
| MAX_USER_CONNECTIONS <次数>
```

1) <列名>

可选项。用于指定权限要授予给表中哪些具体的列。

2) ON 子句

用于指定权限授予的对象和级别，如在 ON 关键字后面给出要授予权限的数据库名或表名等。

3) <权限级别>

用于指定权限的级别。可以授予的权限有如下几组：

- 列权限，和表中的一个具体列相关。例如，可以使用 UPDATE 语句更新表 students 中 student_name 列的值的权限。
- 表权限，和一个具体表中的所有数据相关。例如，可以使用 SELECT 语句查询表 students 的所有数据的权限。
- 数据库权限，和一个具体的数据库中的所有表相关。例如，可以在已有的数据库 mytest 中创建新表的权限。
- 用户权限，和 MySQL 中所有的数据库相关。例如，可以删除已有的数据库或者创建一个新的数据库的权限。

#### 删除用户权限

MySQL 数据库中可以使用 REVOKE 语句删除一个用户的权限，此用户不会被删除。

语法格式有两种形式，如下所示：

1) 第一种：

```SQL
REVOKE <权限类型> [ ( <列名> ) ] [ , <权限类型> [ ( <列名> ) ] ]…
ON <对象类型> <权限名> FROM <用户1> [ , <用户2> ]…
```

2) 第二种：

```sql
REVOKE ALL PRIVILEGES, GRANT OPTION
FROM user <用户1> [ , <用户2> ]…
```

语法说明如下：

- REVOKE 语法和 GRANT 语句的语法格式相似，但具有相反的效果。
- 第一种语法格式用于回收某些特定的权限。
- 第二种语法格式用于回收特定用户的所有权限。
- 要使用 REVOKE 语句，必须拥有 MySQL 数据库的全局 CREATE USER 权限或 UPDATE 权限。

### 数据备份与恢复

#### 备份与恢复概述

可以根据不同的类型来划分备份的方法。根据备份的方法不同可以将备份分为：

□ Hot Backup（热备）

□ Cold Backup（冷备）

□ Warm Backup（温备）

Hot Backup是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。这种方式在MySQL官方手册中称为Online Backup（在线备份）。Cold Backup是指备份操作是在数据库停止的情况下，这种备份最为简单，一般只需要复制相关的数据库物理文件即可。这种方式在MySQL官方手册中称为Offline Backup（离线备份）。Warm Backup备份同样是在数据库运行中进行的，但是会对当前数据库的操作有所影响，如加一个全局读锁以保证备份数据的一致性。

按照备份后文件的内容，备份又可以分为：

□ 逻辑备份

□ 裸文件备份

在MySQL数据库中，逻辑备份是指备份出的文件内容是可读的，一般是文本文件。内容一般是由一条条SQL语句，或者是表内实际数据组成。如mysqldump和SELECT*INTO OUTFILE的方法。这类方法的好处是可以观察导出文件的内容，一般适用于数据库的升级、迁移等工作。但其缺点是恢复所需要的时间往往较长。裸文件备份是指复制数据库的物理文件，既可以是在数据库运行中的复制（如ibbackup、xtrabackup这类工具），也可以是在数据库停止运行时直接的数据文件复制。这类备份的恢复时间往往较逻辑备份短很多。

若按照备份数据库的内容来分，备份又可以分为：

□ 完全备份

□ 增量备份

□ 日志备份

#### 冷备

冷备的优点是：□ 备份简单，只要复制相关文件即可。□ 备份文件易于在不同操作系统，不同MySQL版本上进行恢复。□ 恢复相当简单，只需要把文件恢复到指定位置即可。□ 恢复速度快，不需要执行任何SQL语句，也不需要重建索引。

冷备的缺点是：□ InnoDB存储引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如undo段，插入缓冲等信息。□ 冷备也不总是可以轻易地跨平台。操作系统、MySQL的版本、文件大小写敏感和浮点数格式都会成为问题。

#### 逻辑备份

![image-20200321170644096](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321170644096.png)



![image-20200321170708084](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321170708084.png)

#### 二进制日志备份与恢复

二进制日志非常关键，用户可以通过它完成point-in-time的恢复工作。MySQL数据库的replication同样需要二进制日志。在默认情况下并不启用二进制日志，要使用二进制日志首先必须启用它。

要恢复二进制日志也是非常简单的，通过mysqlbinlog即可。

![image-20200321170759508](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321170759508.png)

#### 热备

ibbackup是InnoDB存储引擎官方提供的热备工具，可以同时备份MyISAM存储引擎和InnoDB存储引擎表。

XtraBackup备份工具是由Percona公司开发的开源热备工具。支持MySQL5.0以上的版本。XtraBackup在GPL v2开源下发布，官网地址是：https：//launchpad.net/percona-xtrabackup。

XtraBackup实现增量备份

#### 快照备份

MySQL数据库本身并不支持快照功能，因此快照备份是指通过文件系统支持的快照功能对数据库进行备份。备份的前提是将所有数据库文件放在同一文件分区中，然后对该分区进行快照操作。支持快照功能的文件系统和设备包括FreeBSD的UFS文件系统，Solaris的ZFS文件系统，GNU/Linux的逻辑管理器（Logical Volume Manager，LVM）等。

### MySQL日志

#### 日志简介

MySQL日志主要分为4类，使用这些日志文件，可以查看MySQL内部发生的事情。

这4类日志分别是：

●　错误日志：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题。

●　查询日志：记录建立的客户端连接和执行的语句。

●　二进制日志：记录所有更改数据的语句，可以用于数据复制。

●　慢查询日志：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询。

#### 错误日志

错误日志文件对MySQL的启动、运行、关闭过程进行了记录。MySQL DBA在遇到问题时应该首先查看该文件以便定位问题。该文件不仅记录了所有的错误信息，也记录一些警告信息或正确的信息。用户可以通过命令SHOW VARIABLES LIKE 'log_error'来定位该文件。

#### 慢查询日志

慢查询日志（slow log）可帮助DBA定位可能存在问题的SQL语句，从而进行SQL语句层面的优化。例如，可以在MySQL启动时设一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。DBA每天或每过一段时间对其进行检查，确认是否有SQL语句需要进行优化。该阈值可以通过参数long_query_time来设置，默认值为10，代表10秒。在默认情况下，MySQL数据库并不启动慢查询日志，用户需要手工将这个参数设为ON。

#### 查询日志

查询日志记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。默认文件名为：主机名.log。

#### 二进制日志

二进制日志（binary log）记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。然而，若操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。

进制日志主要有以下几种作用。

□ 恢复（recovery）：某些数据的恢复需要二进制日志，例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。

□ 复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或standby）与一台MySQL数据库（一般称为master或primary）进行实时同步。

□ 审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入的攻击。

### 性能优化

#### mysql explain执行计划详解

![img](https://images2015.cnblogs.com/blog/763020/201604/763020-20160417142105895-121211600.png)

 

1）、id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。

2）、select_type列常见的有：

A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个

B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个

C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union

D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响

E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null

F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery

G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响

H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select

3）、table

显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的<derived N>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的<union M,N>，与<derived N>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。

4）、type

依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引

A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index

B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描

C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref

D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。

E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引

F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。

G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值

H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。

I：range：索引范围扫描，常见于使用>,<,is null,between ,in ,like等运算符的查询中。

J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range

K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。

L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。

5）、possible_keys

查询可能使用到的索引都会在这里列出来

6）、key

查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。

7）、key_len

用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。

8）、ref

如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func

9）、rows

这里是执行计划中估算的扫描行数，不是精确值

10）、extra

这个列可以显示的信息非常多，有几十种，常用的有

A：distinct：在select部分使用了distinc关键字

B：no tables used：不带from字句的查询或者From dual查询

C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。

D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中

E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。

F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。

G：using sort_union，using_union，using intersect，using sort_intersection：

using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集

using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集

using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。

H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。

I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition

J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个

K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个

除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息

11）、filtered

使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。

#### 优化MySQL的参数

●　key_buffer_size：表示索引缓冲区的大小。索引缓冲区所有的线程共享。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值也不是越大越好，它的大小取决于内存的大小。如果这个值太大，导致操作系统频繁换页，也会降低系统性能。

●　table_cache：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。

●　query_cache_size：表示查询缓冲区的大小。该参数需要和query_cache_type配合使用。当query_cache_type值是0时，所有的查询都不使用查询缓冲区。但是query_cache_type=0并不会导致MySQL释放query_cache_size所配置的缓冲区内存。当query_cache_type=1时，所有的查询都将使用查询缓冲区，除非在查询语句中指定SQL_NO_CACHE，如SELECT SQL_NO_CACHE * FROM tbl_name。当query_cache_type=2时，只有在查询语句中使用SQL_CACHE关键字，查询才会使用查询缓冲区。使用查询缓冲区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。

●　sort_buffer_size ：表示排序缓存区的大小。这个值越大，进行排序的速度越快。

●　read_buffer_size ：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSIONread_buffer_size=n可以临时设置该参数的值。

●　read_rnd_buffer_size ：表示为每个线程保留的缓冲区的大小，与read_buffer_size相似。但主要用于存储按特定顺序读取出来的记录。也可以用SETSESSION read_rnd_buffer_size=n来临时设置该参数的值。如果频繁进行多次连续扫描，可以增加该值。

●　innodb_buffer_pool_size：表示InnoDB类型的表和索引的最大缓存。这个值越大，查询的速度就会越快，但是这个值太大会影响操作系统的性能。

●　max_connections：表示数据库的最大连接数。这个连接数不是越大越好，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。

●　innodb_flush_log_at_trx_commit：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。值为0时表示每隔1秒将数据写入日志文件并将日志文件写入磁盘；值为1时表示每次提交事务时将数据写入日志文件并将日志文件写入磁盘；值为2时表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。该参数的默认值为1。默认值1安全性最高，但是每次事务提交或事务外的指令都需要把日志写入（flush）硬盘，是比较费时的；0值更快一点，但安全方面比较差；2值日志仍然会每秒写入到硬盘，所以即使出现故障，一般也不会丢失超过1~2秒的更新。

●　back_log：表示在MySQL暂时停止回答新请求之前的短时间内，多少个请求可以被存在堆栈中。换句话说，该值表示对到来的TCP/IP连接的侦听队列的大小。只有期望在一个短时间内有很多连接时才需要增加该参数的值。操作系统在这个队列大小上也有限制，设定back_log高于操作系统的限制将是无效的。

●　interactive_timeout：表示服务器在关闭连接前等待行动的秒数。

●　sort_buffer_size：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高ORDER BY或GROUP BY操作的速度，默认数值是2097144字节（约2MB）。

●　thread_cache_size：表示可以复用的线程的数量。如果有很多新的线程，为了提高性能可以增大该参数的值。

●　wait_timeout：表示服务器在关闭一个连接时等待行动的秒数，默认数值是28800。

#### 合理地设置RAID

RAID（Redundant Array of Independent Disks，独立磁盘冗余数组）的基本思想就是把多个相对便宜的硬盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。由于将多个硬盘组合成为一个逻辑扇区，RAID看起来就像一个单独的硬盘或逻辑存储单元，因此操作系统只会把它当作一个硬盘。

RAID的作用是：

□ 增强数据集成度

□ 增强容错功能

□ 增加处理量或容量

根据不同磁盘的组合方式，常见的RAID组合方式可分为RAID 0、RAID 1、RAID 5、RAID 10和RAID 50等。

**RAID0**

- 数据在从内存缓冲区写入磁盘时，根据磁盘数量将数据分成N份，这些数据同时并发写入N块磁盘，使得数据整体写入速度是一块磁盘的N倍。读取的时候也一样，因此RAID0具有极快的数据读写速度，但是RAID0不做数据备份，N块磁盘中只要有一块损坏，数据完整性就被破坏，所有磁盘的数据都会损坏。

**RAID1**

- 数据在写入磁盘时，将一份数据同时写入两块磁盘，这样任何一块磁盘损坏都不会导致数据丢失，插入一块新磁盘就可以通过复制数据的方式自动修复，具有极高的可靠性。

**RAID3**

- 一般情况下，一台服务器上不会出现同时损坏两块磁盘的情况，在只损坏一块磁盘的情况下，如果能利用其他磁盘的数据恢复损坏磁盘的数据，这样在保证可靠性和性能的同时，磁盘利用率也得到大幅提升。
- 在数据写入磁盘的时候，将数据分成N-1份，并发写入N-1块磁盘，并在第N块磁盘记录校验数据，任何一块磁盘损坏（包括校验数据磁盘），都可以利用其他N-1块磁盘的数据修复。
- 但是在数据修改较多的场景中，任何磁盘修改数据都会导致第N块磁盘重写校验数据，频繁写入的后果是第N块磁盘比其他磁盘容易损坏，需要频繁更换，所以RAID3很少在实践中使用。

**RAID5**

- 相比RAID3，更多被使用的方案是RAID5。
- RAID5和RAID3很相似，但是校验数据不是写入第N块磁盘，而是螺旋式地写入所有磁盘中。这样校验数据的修改也被平均到所有磁盘上，避免RAID3频繁写坏一块磁盘的情况。

**RAID6**

- 如果数据需要很高的可靠性，在出现同时损坏两块磁盘的情况下（或者运维管理水平比较落后，坏了一块磁盘但是迟迟没有更换，导致又坏了一块磁盘），仍然需要修复数据，这时候可以使用RAID6。
- RAID6和RAID5类似，但是数据只写入N-2块磁盘，并螺旋式地在两块磁盘中写入校验信息（使用不同算法生成）。

**RAID10**

- 结合RAID0和RAID1两种方案，将所有磁盘平均分成两份，数据同时在两份磁盘写入，相当于RAID1，但是在每一份磁盘里面的N/2块磁盘上，利用RAID0技术并发读写，既提高可靠性又改善性能，不过RAID10的磁盘利用率较低，有一半的磁盘用来写备份数据。

![img](https://img2018.cnblogs.com/blog/1444343/201908/1444343-20190830160532089-1359602064.png)



#### 合适的基准测试工具

sysbench是一个模块化的、跨平台的多线程基准测试工具，主要用于测试各种不同系统参数下的数据库负载情况。

mysql-tpcc

TPC（Transaction Processing Performance Council，事务处理性能协会）是一个用来评价大型数据库系统软硬件性能的非盈利组织。TPC-C是TPC协会制定的，用来测试典型的复杂OLTP（在线事务处理）系统的性能。目前在学术界和工业界普遍采用TPC-C来评价OLTP应用的性能。

####  逻辑查询优化

![image-20200411164101915](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200411164101915.png)

![image-20200411164116156](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200411164116156.png)

![image-20200411164235383](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200411164235383.png)

#### 查询重写规则

传统的联机事务处理（On-line Transaction Processing，OLTP）使用基于选择（SELECT）、投影（PROJECT）、连接（JOIN）3种基本操作相结合的查询，这种查询称为SPJ查询。

数据库在查询优化的过程中，会对这3种基本操作进行优化。优化的方式如下：

❏选择操作。对应的是限制条件（格式类似field＜op＞consant，field表示列对象，op是操作符，如=、＞等），优化方式是选择操作下推，目的是尽量减少连接操作前的元组数，使得中间临时关系尽量少（元组数少，连接得到的元组数就少），这样可减少IO和CPU的消耗，节约内存空间。

❏投影操作。对应的SELECT查询的目的列对象，优化方式是投影操作下推，目的是尽量减少连接操作前的列数，使得中间临时关系尽量小（特别注意差别：选择操作是使元组的个数“尽量少”，投影操作是使一条元组“尽量小”），这样虽然不能减少IO（多数数据库存储方式是行存储，元组是读取的最基本单位，所以要想操作列则必须读取一行数据），但可以各减少连接后的中间关系的元组大小，节约内存空间。

❏连接操作。对应的是连接条件（格式类似field_1＜op＞field_2，field_1和field_2表示不同表上的列对象，op是操作符，如=、＞等），表示两个表连接的条件。

#### 子查询的优化

子查询是查询语句中经常出现的一种类型，是比较耗时的操作。优化子查询对查询效率的提升有着直接的影响，所以子查询优化技术，是数据库查询优化引擎的重要研究内容。从子查询出现在SQL语句的位置看，它可以出现在目标列、FROM子句、WHERE子句、JOIN/ON子句、GROUPBY子句、HAVING子句、ORDERBY子句等位置。子查询出现在不同位置对优化的影响如下：

❏目标列位置。子查询如果位于目标列，则只能是标量子查询，否则数据库可能返回类似“错误：子查询必须只能返回一个字段”的提示。

❏FROM子句位置。相关子查询出现在FROM子句中，数据库可能返回类似“在FROM子句中的子查询无法参考相同查询级别中的关系”的提示，所以相关子查询不能出现在FROM子句中；非相关子查询出现在FROM子句中，可上拉子查询到父层，在多表连接时统一考虑连接代价后择优。

❏WHERE子句位置。出现在WHERE子句中的子查询是一个条件表达式的一部分，而表达式可以分解为操作符和操作数；根据参与运算的数据类型的不同，操作符也不尽相同，如INT型有＞、＜、=、＜＞等操作，这对子查询均有一定的要求（如INT型的等值操作，要求子查询必须是标量子查询）。另外，子查询出现在WHERE子句中的格式也有用谓词指定的一些操作，如IN、BETWEEN、EXISTS等。

❏JOIN/ON子句位置。JOIN/ON子句可以拆分为两部分，一是JOIN块类似于FROM子句，二是ON子句块类似于WHERE子句，这两部分都可以出现子查询。子查询的处理方式同FROM子句和WHERE子句。

❏GROUPBY子句位置。目标列必须和GROUPBY关联[插图]。可将子查询写在GROUPBY位置处，但子查询用在GROUPBY处没有实用意义。

❏ORDERBY子句位置。可将子查询写在ORDERBY位置处。但ORDERBY操作是作用在整条SQL语句上的，子查询用在ORDERBY处没有实用意义。

子查询优化技术的思路如下：

❏子查询合并（Subquery Coalescing）。在某些条件下（语义等价：两个查询块产生同样的结果集），多个子查询能够合并成一个子查询（合并后还是子查询，以后可以通过其他技术消除子查询）。

❏子查询展开（Subquery Unnesting）。又称子查询反嵌套，又称为子查询上拉。把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列，其实质是把某些子查询重写为等价的多表连接操作（展开后，子查询不存在了，外层查询变成了多表连接）。带来的好处是，有关的访问路径、连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能地减少。

❏聚集子查询消除（Aggregate Subquery Elimination）。聚集函数上推，将子查询转变为一个新的不包含聚集函数的子查询，并与父查询的部分或者全部表做左外连接。

#### 条件化简

WHERE、HAVING和ON条件由许多表达式组成，而这些表达式在某些时候彼此之间存在一定的联系。利用等式和不等式的性质，可以将WHERE、HAVING和ON条件化简，但不同数据库的实现可能不完全相同。

将WHERE、HAVING和ON条件化简的方式通常包括如下几个：

❏把HAVING条件并入WHERE条件。便于统一、集中化解条件子句，节约多次化解时间。但不是任何情况下HAVING条件都可以并入WHERE条件，只有在SQL语句中不存在GROUPBY条件或聚集函数的情况下，才能将HAVING条件与WHERE条件的进行合并。

❏去除表达式中冗余的括号。这样可以减少语法分析时产生的AND和OR树的层次。如((aAND b)AND(c AND d))就可以化简为a AND b AND c AND d。

❏常量传递。对不同关系可以使得条件分离后有效实施“选择下推”，从而可以极大地减小中间关系的规模。如col_1=col_2AND col_2=3就可以化简为col_1=3AND col_2=3。操作符=、＜、＞、＜=、＞=、＜＞、LIKE中的任何一个，在col_1＜操作符＞col_2条件中都会发生常量传递。

❏消除死码。化简条件，将不必要的条件去除。如WHERE(0＞1AND s1=5)，0＞1使得AND恒为假，则WHERE条件恒为假。此时就不必再对该SQL语句进行优化和执行了，加快了查询执行的速度。

❏表达式计算。对可以求解的表达式进行计算，得出结果。如WHERE col_1=1+2变换为WHERE col_1=3。

❏等式变换。化简条件（如反转关系操作符的操作数的顺序），从而改变某些表的访问路径。如-a=3可化简为a=-3。这样的好处是如果a上有索引，则可以利用索引扫描来加快访问。

❏不等式变换。化简条件，将不必要的重复条件去除。如a＞10AND b=6AND a＞2可化简为b=6AND a＞10。

❏布尔表达式变换。在上面的内容中，涉及了一些布尔表达式参与的变换（如上一条中的示例是AND的表达式）。布尔表达式还有如下规则指导化简。

#### 表数据的访问方式

![image-20200411165344534](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200411165344534.png)

### MySQL Replication

#### MySQL Replication

MySQL复制是指从一个MySQL主服务器（master）将数据复制到另一台或多台MySQL从服务器（slaves）的过程，将主数据库的DDL和DML操作通过二进制日志传到从服务器上，然后在从服务器上对这些日志重新执行，从而使得主从服务器的数据保持同步。

在MySQL中，复制操作是异步进行的，slaves服务器不需要持续地保持连接接收master服务器的数据。

MySQL支持一台主服务器同时向多台从服务器进行复制操作，从服务器同时可以作为其他从服务器的主服务器，如果MySQL主服务器访问量比较大，可以通过复制数据，然后在从服务器上进行查询操作，从而降低主服务器的访问压力，同时从服务器作为主服务器的备份，可以避免主服务器因为故障数据丢失的问题。

MySQL数据库复制操作大致可以分成3个步骤：

步骤01　主服务器将数据的改变记录到二进制日志（binary log）中。

步骤02　从服务器将主服务器的binary log events复制到它的中继日志（relay log）中。

步骤03　从服务器重做中继日志中的事件，将数据的改变与从服务器保持同步。

通过SHOW SLAVE STATUS命令可以观察当前复制的运行状态，一些主要的变量如表8-1所示。

![image-20200321170948785](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321170948785.png)

#### 复制的原理

Mysql的复制原理大致如下：
1.主库在数据提交时会把数据变更作为事件记录在二进制日志文件Binlog中；可通过sync_binlog控制binlog日志刷新到磁盘的频率；
2.主库推送二进制日志文件binlog中的事件到从库的中继日志Relay Log，之后从库根据中继日志RelayLog重做数据变更操作，通过逻辑复制达到主从库的数据一致；
3.MySQL通过3个线程来完成主从库之间的数据同步，其中binlog dump线程跑在主库上，I/O线程和sql线程跑在从库上。

当从库启动复制时，首先创建I/O线程连接主库，主库随后创建binlog dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志replay log中去，之后从库上的sql线程读取中继日志中更新的数据库事件并应用；

![img](https://oscimg.oschina.net/oscnet/cd4cefb5704b71a1e5a2169a8b1017d633e.jpg)

#### MySQL复制架构

□ 主从模式　A→B

□ 主主模式　A←→B

□ 链式复制模式　A→B→C

□ 环形复制模式　A→B→C→A

以上4种模式为复制的主要模式，生产中一般建议部署为主从模式，这也是最稳健的一种方式。

为了方便切换，在一定程度上提高可用性，也可以选择主主模式。需要注意的是，主主模式必须确保任何时刻都只有一个数据库是主动（Active）状态，也就是说同一个时刻只能写入一个主（Master）节点，否则可能导致数据异常。

链式或环形复制在生产中很少用到，它们的主要缺点在于，随着节点的增加，整个复制系统的稳健性会下降。

### MySQL存储引擎

#### InnoDB存储引擎：

InnoDB存储引擎：支持事务，其设计目标主要面向联机事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL 5.5.8版本开始是默认的存储引擎。

InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别，同时使用一种称为netx-key locking的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB存储引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。

对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，每张表都是按主键的顺序进行存储的，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。

#### MyISAM存储引擎：

MyISAM存储引擎：不支持事务、表锁设计、支持全文索引，主要面向一些OLAP数据库应用，在MySQL 5.5.8版本之前是默认的存储引擎（除Windows版本外）。数据库系统与文件系统一个很大的不同在于对事务的支持， MyISAM存储引擎是不支持事务的。究其根本，这也并不难理解。用户在所有的应用中是否都需要事务呢？在数据仓库中，如果没有ETL这些操作，只是简单地通过报表查询还需要事务的支持吗？此外，MyISAM存储引擎的另一个与众不同的地方是，它的缓冲池只缓存（cache）索引文件，而不缓存数据文件，这与大多数的数据库都不相同。

#### NDB存储引擎：

NDB存储引擎：2003年，MySQL AB公司从Sony Ericsson公司收购了NDB存储引擎。NDB存储引擎是一个集群存储引擎，类似于Oracle的RAC集群，不过与Oracle RAC的share everything结构不同的是，其结构是share nothing的集群架构，因此能提供更高级别的高可用性。NDB存储引擎的特点是数据全部放在内存中（从5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找（primary key lookups）的速度极快，并且能够在线添加NDB数据存储节点（data node）以便线性地提高数据库性能。由此可见，NDB存储引擎是高可用、高性能、高可扩展性的数据库集群系统，其面向的也是OLTP的数据库应用类型。

#### Memory存储引擎：

Memory存储引擎：正如其名，Memory存储引擎中的数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。它非常适合于存储OLTP数据库应用中临时数据的临时表，也可以作为OLAP数据库应用中数据仓库的维度表。Memory存储引擎默认使用哈希索引，而不是通常熟悉的B+树索引。

#### Infobright存储引擎：

Infobright存储引擎： 第三方的存储引擎。其特点是存储是按照列而非行的，因此非常适合OLAP的数据库应用。其官方网站是www.infobright.org/，上面有不少成功的数据仓库案例可供分析。

#### NTSE存储引擎：

NTSE存储引擎：网易公司开发的面向其内部使用的存储引擎。目前的版本不支持事务，但提供压缩、行级缓存等特性，不久的将来会实现面向内存的事务支持。

#### Archive存储引擎

Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。

#### Federated存储引擎

Federated存储引擎表并不存放数据，它只是指向一台远程MySQL数据库服务器上的表。这非常类似于SQL Server的链接服务器和Oracle的透明网关，不同的是，当前Federated存储引擎只支持MySQL数据库表，不支持异构数据库表。

#### Maria存储引擎

Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。Maria存储引擎的开发者是MySQL的创始人之一的MichaelWidenius。因此，它可以看做是MyISAM的后续版本。Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。

### MySQL事务

#### ACID

从理论上说，事务有着极其严格的定义，它必须同时满足4个特性，即通常所说事务的ACID特性。

A（atomicity），原子性。原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

I（isolation），隔离性。隔离性还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。

D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。

#### 脏读

在理解脏读（Dirty Read）之前，需要理解脏数据的概念。但是脏数据和之前所介绍的脏页完全是两种不同的概念。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的，当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中。而所谓脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。

#### 不可重复读

不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读。

#### 幻读

同样的条件，第1次和第2次读出来的记录数不一样。

#### 事务的分类

从事务理论的角度来说，可以把事务分为以下几种类型：

□ 扁平事务（Flat Transactions）

□ 带有保存点的扁平事务（Flat Transactions with Savepoints）

□ 链事务（Chained Transactions）

□ 嵌套事务（Nested Transactions）

□ 分布式事务（Distributed Transactions）

扁平事务是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。因此，扁平事务是应用程序成为原子操作的基本组成模块。

带有保存点的扁平事务（Flat Transactions with Savepoint），除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（Savepoint）用来通知系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。

链事务（Chained Transaction）可视为保存点模式的一种变种。带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（volatile），而非持久的（persistent）。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行。

嵌套事务（Nested Transaction）是一个层次结构框架。由一个顶层事务（top-leveltransaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。

分布式事务（Distributed Transactions）通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。

#### 事务的隔离级别

InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。这与其他数据库系统（如Microsoft SQL Server数据库）是不同的。所以说，InnoDB存储引擎在默认的REPEATABLE READ事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。

数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。

**Read uncommitted**

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

**Read committed**

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

**Repeatable read**

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

**Serializable 序列化**

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

#### redo

重做日志用来实现事务的持久性，即事务ACID中的D。其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。

InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交（COMMIT）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的COMMIT操作完成才算完成。这里的日志是指重做日志，在InnoDB存储引擎中，由两部分组成，即redo log和undo log。redo log用来保证事务的持久性，undo log用来帮助事务回滚及MVCC的功能。redo log基本上都是顺序写的，在数据库运行时不需要对redo log的文件进行读取操作。而undo log是需要进行随机读写的。

#### undo

重做日志记录了事务的行为，可以很好地通过其对页进行“重做”操作。但是事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

redo存放在重做日志文件中，与redo不同，undo存放在数据库内部的一个特殊段（segment）中，这个段称为undo段（undo segment）。undo段位于共享表空间内。可以通过py_innodb_page_info.py工具来查看当前共享表空间中undo的数量。

####  purge

purge用于最终完成delete和update操作。这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事物可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。可见，purge操作是清理之前的delete和update操作，将上述操作“最终”完成。而实际执行的操作为delete操作，清理之前行记录的版本。

#### group commit

若事务为非只读事务，则每次事务提交时需要进行一次fsync操作，以此保证重做日志都已经写入磁盘。当数据库发生宕机时，可以通过重做日志进行恢复。虽然固态硬盘的出现提高了磁盘的性能，然而磁盘的fsync性能是有限的。为了提高磁盘fsync的效率，当前数据库都提供了groupcommit的功能，即一次fsync可以刷新确保多个事务日志被写入文件。对于InnoDB存储引擎来说，事务提交时会进行两个阶段的操作：

1）修改内存中事务对应的信息，并且将日志写入重做日志缓冲。

2）调用fsync将确保日志都从重做日志缓冲写入磁盘。

#### 事务控制语句

□ START TRANSACTION | BEGIN：显式地开启一个事务。

□ COMMIT：要想使用这个语句的最简形式，只需发出COMMIT。也可以更详细一些，写为COMMIT WORK，不过这二者几乎是等价的。COMMIT会提交事务，并使得已对数据库做的所有修改成为永久性的。

□ ROLLBACK：要想使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。

□ SAVEPOINT identifier∶SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT。

□ RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这句语句时，会抛出一个异常。

□ ROLLBACK TO[SAVEPOINT]identifier：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。例如可以发出两条UPDATE语句，后面跟一个SAVEPOINT，然后又是两条DELETE语句。如果执行DELETE语句期间出现了某种异常情况，并且捕获到这个异常，同时发出了ROLLBACK TO SAVEPOINT命令，事务就会回滚到指定的SAVEPOINT，撤销DELETE完成的所有工作，而UPDATE语句完成的工作不受影响。

□ SET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE。

#### 分布式事务

InnoDB存储引擎提供了对于XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources） 参与到一个全局的事务中。事务资源通常是关系型数据库系统，也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。

XA事务由一个或多个资源管理器（resource manager）、一个事务管理器（transaction manager）以及一个应用程序（applicationprogram）组成。资源管理器：提供访问事务资源的方法。通常一个数据库就是一个资源管理器。事务管理器：协调参与全局事务中的各个事务。需要和参与到全局事务中的所有资源管理器进行通信。应用程序：定义事务的边界，指定全局事务中的操作。

分布式事务使用两段式提交（two-phase commit）的方式。在第一个阶段，所有参与全局事务的节点都开始准备（PREPARE），告诉事务管理器它们准备好提交了。第二个阶段，事务管理器告诉资源管理器执行ROLLBACK还是COMMIT。如果任何一个节点显示不能提交，则所有的节点都被告知需要回滚。可见与本地事务不同的是，需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或ROLLBACK操作。

![image-20200321170242925](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321170242925.png)

#### 内部XA事务

在MySQL数据库中还存在另外一种分布式事务，其在存储引擎与插件之间，又或者在存储引擎与存储引擎之间，称之为内部XA事务。

最为常见的内部XA事务存在于binlog与InnoDB存储引擎之间。由于复制的需要，因此目前绝大多数的数据库都开启了binlog功能。在事务提交时，先写二进制日志，再写InnoDB存储引擎的重做日志。对上述两个操作的要求也是原子的，即二进制日志和重做日志必须同时写入。若二进制日志先写了，而在写入InnoDB存储引擎时发生了宕机，那么slave可能会接收到master传过去的二进制日志并执行，最终导致了主从不一致的情况。

### MySQL安全管理

#### SQL注入

SQL注入（SQL Injection）攻击是发生在应用程序中的数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的SQL语句就会被数据库服务器误认为是正常的SQL语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

#### 避免SQL注入

（1）过滤输入内容，校验字符串

（2）参数化查询

（3）安全测试、安全审计

### InnoDB存储引擎

#### InnoDB体系架构

![image-20200321160659397](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321160659397.png)

□ 维护所有进程/线程需要访问的多个内部数据结构。□ 缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。□ 重做日志（redo log）缓冲。

####  后台线程

1. Master ThreadMaster Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等。
2.  IO Thread在InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（call back）处理。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。

3. Purge Thread事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。

4. Page Cleaner ThreadPage Cleaner Thread是在InnoDB 1.2.x版本中引入的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。

#### 内存

1. 缓冲池

   InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统（Disk-base Database）。在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。

   缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。

2. LRU List、Free List和Flush List

   通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。

   在InnoDB存储引擎中，缓冲池中页的大小默认为16KB，同样使用LRU算法对缓冲池进行管理。稍有不同的是InnoDB存储引擎对传统的LRU算法做了一些优化。在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB存储引擎下称为midpoint insertion strategy。

3. 重做日志缓冲

   InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。

4. 额外的内存池

   额外的内存池通常被DBA忽略，他们认为该值并不十分重要，事实恰恰相反，该值同样十分重要。在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。

#### Checkpoint技术

Checkpoint（检查点）技术的目的是解决以下几个问题：□ 缩短数据库的恢复时间；□ 缓冲池不够用时，将脏页刷新到磁盘；□ 重做日志不可用时，刷新脏页。

在InnoDB存储引擎内部，有两种Checkpoint，分别为：□ Sharp Checkpoint□ Fuzzy Checkpoint

#### 插入缓冲

1. Insert Buffer

   Insert Buffer可能是InnoDB存储引擎关键特性中最令人激动与兴奋的一个功能。不过这个名字可能会让人认为插入缓冲是缓冲池中的一个组成部分。其实不然，InnoDB缓冲池中有InsertBuffer信息固然不错，但是Insert Buffer和数据页一样，也是物理页的一个组成部分。

Insert Buffer的使用需要同时满足以下两个条件：□ 索引是辅助索引（secondary index）；□ 索引不是唯一（unique）的。

2. Change Buffer

   InnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purge buffer。

3. Insert Buffer的内部实现

Insert Buffer是一棵B+树，因此其也由叶节点和非叶节点组成。非叶节点存放的是查询的search key（键值），其构造如图2-3所示。

![image-20200321161540533](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321161540533.png)

4. #### Merge Insert Buffer

   Merge Insert Buffer的操作可能发生在以下几种情况下：□ 辅助索引页被读取到缓冲池时；□ Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；□ Master Thread。

#### 两次写

如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite（两次写）带给InnoDB存储引擎的是数据页的可靠性。

![image-20200321161709706](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321161709706.png)

doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。

#### 自适应哈希索引

InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。

#### 异步IO

为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO，AIO）的方式来处理磁盘操作。InnoDB存储引擎亦是如此。

与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没有必要的。用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。

#### 刷新邻接页

InnoDB存储引擎还提供了Flush Neighbor Page（刷新邻接页）的特性。其工作原理为：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。

为此，InnoDB存储引擎从1.2.x版本开始提供了参数innodb_flush_neighbors，用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性。

#### InnoDB存储引擎文件

![image-20200321162650963](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321162650963.png)

#### 表空间文件

InnoDB采用将存储的数据按表空间（tablespace）进行存放的设计。在默认配置下会有一个初始大小为10MB，名为ibdata1的文件。该文件就是默认的表空间文件（tablespace file），用户可以通过参数innodb_data_file_path对其进行设置。

#### 重做日志文件

每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。为了得到更高的可靠性，用户可以设置多个的镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。

### InnoDB存储引擎索引

####  InnoDB存储引擎索引

InnoDB存储引擎支持以下几种常见的索引：□ B+树索引□ 全文索引□ 哈希索引

#### B+树索引

数据库中的B+树索引可以分为聚集索引（clustered inex）和辅助索引（secondary index），但是不管是聚集还是辅助的索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

#### 聚集索引

聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。

#### 辅助索引

对于辅助索引（Secondary Index，也称非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键。

#### 联合索引

联合索引是指对表上的多个列进行索引。前面讨论的情况都是只对表上的一个列进行索引。联合索引的创建方法与单个索引创建的方法一样，不同之处仅在于有多个索引列。

#### 覆盖索引

InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

#### 索引提示

MySQL数据库支持索引提示（INDEX HINT），显式地告诉优化器使用哪个索引。个人总结以下两种情况可能需要用到INDEX HINT：

□ MySQL数据库的优化器错误地选择了某个索引，导致SQL语句运行的很慢。这种情况在最新的MySQL数据库版本中非常非常的少见。优化器在绝大部分情况下工作得都非常有效和正确。这时有经验的DBA或开发人员可以强制优化器使用某个索引，以此来提高SQL运行的速度。

□ 某SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。例如，优化器分析Range查询本身就是比较耗时的操作。这时DBA或开发人员分析最优的索引选择，通过Index Hint来强制使优化器不进行各个执行路径的成本分析，直接选择指定的索引来完成查询。

#### Multi-Range Read优化

MySQL5.6版本开始支持Multi-Range Read（MRR）优化。Multi-Range Read优化的目的就是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这对于IO-bound类型的SQL查询语句可带来性能极大的提升。Multi-Range Read优化可适用于range，ref，eq_ref类型的查询。

MRR优化有以下几个好处：

□ MRR使数据访问变得较为顺序。在查询辅助索引时，首先根据得到的查询结果，按照主键进行排序，并按照主键排序的顺序进行书签查找。

□ 减少缓冲池中页被替换的次数。

□ 批量处理对键值的查询操作。

对于InnoDB和MyISAM存储引擎的范围查询和JOIN查询操作，MRR的工作方式如下：

□ 将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。

□ 将缓存中的键值根据RowID进行排序。

□ 根据RowID的排序顺序来访问实际的数据文件。

#### Index Condition Pushdown（ICP）优化

和Multi-Range Read一样，Index Condition Pushdown同样是MySQL 5.6开始支持的一种根据索引进行查询的优化方式。之前的MySQL数据库版本不支持Index Condition Pushdown，当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。在支持Index Condition Pushdown后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层SQL层对记录的索取（fetch），从而提高数据库的整体性能。

Index Condition Pushdown优化支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。当优化器选择Index Condition Pushdown优化时，可在执行计划的列Extra看到Using index condition提示。

#### 全文检索

全文检索（Full-Text Search）是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。

#### 倒排索引

全文检索通常使用倒排索引（inverted index）来实现。倒排索引同B+树索引一样，也是一种索引结构。它在辅助表（auxiliary table）中存储了单词与单词自身在一个或多个文档中所在位置之间的映射。这通常利用关联数组实现，其拥有两种表现形式：

□ inverted file index，其表现形式为{单词，单词所在文档的ID}

□ full inverted index，其表现形式为{单词，（单词所在文档的ID，在具体文档中的位置）}

### 锁

#### lock与latch

这里还要区分锁中容易令人混淆的概念lock与latch。在数据库中，lock与latch都可以被称为“锁”。

latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。

![image-20200321164046553](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164046553.png)

对于InnoDB存储引擎中的latch，可以通过命令SHOW ENGINE INNODB MUTEX来进行查看。

![image-20200321164124704](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164124704.png)

#### 锁的类型

InnoDB存储引擎实现了如下两种标准的行级锁：

□ 共享锁（S Lock），允许事务读一行数据。

□ 排他锁（X Lock），允许事务删除或更新一行数据。

InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：

1）意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁

2）意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁

![image-20200321164226722](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164226722.png)

用户可以通过命令SHOW ENGINE INNODB STATUS命令来查看当前锁请求的信息。

在InnoDB 1.0版本之前，用户只能通过命令SHOW FULL PROCESSLIST，SHOW ENGINEINNODB STATUS等来查看当前数据库中锁的请求，然后再判断事务锁的情况。从InnoDB1.0开始，在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS。通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。

![image-20200321164342097](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164342097.png)

![image-20200321164357419](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164357419.png)

![image-20200321164409456](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164409456.png)

#### 一致性非锁定读

一致性的非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。

![image-20200321164724223](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321164724223.png)

之所以称其为非锁定读，因为不需要等待访问的行上X锁的释放。快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

#### MVCC

一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control，MVCC）。

#### 一致性锁定读

在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：□ SELECT…FOR UPDATE□ SELECT…LOCK IN SHARE MODE

#### 自增长与锁

虽然AUTO-INC Locking从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。其次，对于INSERT…SELECT的大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。

从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引擎提供了一个参数innodb_autoinc_lock_mode来控制自增长的模式，该参数的默认值为1。在继续讨论新的自增长实现方式之前，需要对自增长的插入进行分类，如表6-9所示。

![image-20200321165030147](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321165030147.png)

![image-20200321165044789](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200321165044789.png)

#### 行锁的3种算法

InnoDB存储引擎有3种行锁的算法，其分别是：

□ Record Lock：单个行记录上的锁

□ Gap Lock：间隙锁，锁定一个范围，但不包含记录本身

□ Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

#### Phantom Problem

在默认的事务隔离级别下，即REPEATABLE READ下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem（幻像问题）。这点可能不同于与其他的数据库，如Oracle数据库，因为其可能需要在SERIALIZABLE的事务隔离级别下才能解决Phantom Problem。

Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

### 数据库设计范式

#### 范式

范式是数据库规范化的一个手段，是数据库设计中的一系列原理和技术，用于减少数据库中的数据冗余，并增进数据的一致性。

#### 第一范式

第一范式是指数据库表的每一列（属性）都是不可分割的基本数据项，这就要求数据库的每一列都只能存放单一值，即实体中的某个属性不能有多个值或不能有重复的属性。第一范式（1NF）是对关系模式的基本要求。

如果每列都是不可再分的最小数据单元（也叫作最小的原子单元），则满足第一范式，第一范式的目标是确保每列的原子性。如图7-3所示，其中的Address列违背了第一范式列不可再分的原则，要满足第一范式，就需要将Address列拆分为Country列和City列。

![image-20200417055201423](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200417055201423.png)

#### 第二范式

一个数据表符合第二范式的前提是该数据表符合第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全相依的关系；如果有哪些数据只和主键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的主键只有单一一个字段的话，那么它就一定符合第二范式。

第二范式在第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖，即第二范式要求每个表只描述一件事情。如图7-4所示，Orders表既包含订单信息，也包含产品信息，需要将其拆分为两个单独的表。

![image-20200417055216842](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200417055216842.png)



#### 第三范式

第三范式的所有非键属性都只和候选键有相关性，也就是说所有非键属性互相之间应该是无关的。候选键指的是能够唯一标识一笔记录的属性的最小集合，一般我们所说的候选键指的就是主键。

第三范式的定义为：满足第一范式和第二范式，并且表中的列不存在对非主键列的传递依赖。如图7-5所示，除了主键的订单编号，顾客姓名依赖于非主键的顾客编号，因此需要将该列去除。

![image-20200417055236466](C:\Users\小硕哥\AppData\Roaming\Typora\typora-user-images\image-20200417055236466.png)

#### BC范式 BCFN

**定义：** 关系模式R<U,F>中，若每一个决定因素都包含码，则R<U,F>属于BCFN。

#### **第四范式 4NF**

**定义：** 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

#### **第五范式 5NF**

第五范式有以下要求：
（1）必须满足第四范式；
（2）表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。

### MySQL 8.0的新特性简述

和MySQL 5.7相比，MySQL 8.0的新特性主要包括以下几个方面。

1．数据字典MySQL 8.0包含一个事务数据字典，用于存储有关数据库对象的信息。在MySQL 8.0之前的版本中，字典数据存储在元数据文件和非事务表中。

2．原子数据定义语句MySQL 8.0支持原子数据定义语言（DDL）语句。此功能称为原子DDL。原子DDL语句将与DDL操作关联的数据字典更新，存储引擎操作和二进制日志写入组合到单个原子事务中。即使服务器在操作期间暂停，也会提交事务，并将适用的更改保留到数据字典、存储引擎和二进制日志，或者回滚事务。通过在MySQL 8.0中引入MySQL数据字典，可以实现原子DDL。在早期的MySQL版本中，元数据存储在元数据文件、非事务性表和存储引擎特定的字典中，需要中间提交。MySQL数据字典提供的集中式事务元数据存储消除了这一障碍，使得将DDL语句操作重组为原子事务成为可能。

3．安全和账户管理MySQL 8.0通过以下功能增强数据库的安全性，并在账户管理中实现更高的DBA灵活性。MySQL数据库的授权表统一为InnoDB（事务性）表。每个语句都是事务性的，并且对所有创建的用户都是成功或者回滚，发生任何错误都无效。如果成功，就将语句写入二进制日志；如果失败则不写入，发生回滚并且不进行任何更改。

MySQL 8.0开始支持角色，角色可以看成是一些权限的集合，为用户赋予统一的角色，权限的修改直接通过角色来进行，无须为每个用户单独授权。管理员可以创建和删除角色。MySQL 8.0开始维护有关密码历史的信息，从而限制了以前密码的重用。管理员可以在全局以及每个账户的基础上建立密码重用策略，从而在密码更改时限制使用以前使用过的密码。MySQL 8.0允许账户具有双密码，从而在多服务器系统中无缝地执行分阶段密码更改，无须停机。

4．资源管理MySQL现在支持资源组的创建和管理，并允许将服务器内运行的线程分配给特定的资源组。资源组属性可以控制其资源，以启用或限制资源组中线程的资源消耗。数据库管理员可以根据不同的工作负载修改这些属性。

5．InnoDB增强功能MySQL 8.0增强了InnoDB的功能，主要表现如下：

（1）MySQL 8.0将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。为了尽量减小对系统性能的影响，计数器写入重做日志时，并不会马上刷新数据库系统。

（2）如果索引损坏，InnoDB将索引损坏标志写入重做日志，从而使得损坏标志安全。InnoDB还将内存中损坏标志数据写入每个检查点上的引擎专用系统表。在恢复期间，InnoDB从两个位置读取损坏标志并在将内存表和索引对象标记为损坏之前合并结果。

（3）新的动态变量innodb_deadlock_detect可用于禁用死锁检测。在高并发系统上，当许多线程等待同一个锁时，死锁检测会导致速度减慢，此时禁用死锁检测可能更有效。

6．字符集支持默认字符集已经更改latin1为utf8mb4。该utf8mb4字符集有几个新的排序规则，其中包括utf8mb4_ja_0900_as_cs。

7．增强JSON功能MySQL增强JSON功能主要表现在以下几个方面：

（1）添加了->>运算符，相当于调用JSON_UNQUOTE()的结果。

（2）添加了两个JSON聚合函数JSON_ARRAYAGG()和JSON_OBJECTAGG()。JSON_ARRAYAGG()将列或表达式作为其参数，并将结果聚合为单个JSON数组。JSON_OBJECTAGG()取两个列或表达式，将其解释为键和值，并将结果作为单个JSON对象返回。

（3）添加了JSON实用程序功能JSON_PRETTY()，JSON以易于阅读的格式输出现有值；每个JSON对象成员或数组值都打印在一个单独的行上，子对象或数组相对于其父对象是2个空格。

（4）添加的JSON_MERGE_PATCH()可以合并符合RFC 7396标准的JSON。在两个JSON对象上使用时，可以将它们合并为单个JSON对象。

8．数据类型的支持MySQL 8.0支持将表达式用作数据类型的默认值，包括BLOB、TEXT、GEOMETRY和JSON数据类型，在以前的版本中是根本不会被分配默认值的。

9．查询的优化MySQL 8.0在查询方面的优化表现如下：

（1）MySQL 8.0开始支持不可见索引。优化器根本不使用不可见索引，但会以其他方式正常维护。默认情况下，索引是可见的。通过不可见索引，数据库管理员可以检测索引对查询性能的影响，而不会进行破坏性的更改。

（2）MySQL8.0开始支持降序索引。DESC在索引定义中不再被忽略，而且会降序存储索引字段。

10．公用表表达式MySQL现在支持非递归和递归的公用表表达式。公用表表达式允许使用命名的临时结果集，通过允许WITH语句之前的子句SELECT和某些其他语句来实现。

11．窗口函数在MySQL 8.0版本中，新增了一个窗口函数，用它可以实现很多新的查询方式。窗口函数类似于SUM()、COUNT()那样的集合函数，但它并不会将多行查询结果合并为一行，而是将结果放回多行当中。

12．统计直方图MySQL 8.0实现了统计直方图。利用直方图，用户可以对一张表的一列做数据分布的统计，特别是针对没有索引的字段。这可以帮助查询优化器找到更优的执行计划。

13．备份锁新类型的备份锁在联机备份期间允许DML，同时防止可能导致快照不一致的操作。新的备份锁由LOCK INSTANCE FOR BACKUP和UNLOCK INSTANCE语法支持。管理员拥有BACKUP_ADMIN权限才能使用这些语句。

